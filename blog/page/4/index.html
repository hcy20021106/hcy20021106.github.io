<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"hechenyi.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://hechenyi.github.io/blog/page/4/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://hechenyi.github.io/blog/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://hechenyi.github.io/2025/05/04/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/05/04/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">算法基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-05-04 01:42:52" itemprop="dateCreated datePublished" datetime="2025-05-04T01:42:52+08:00">2025-05-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-06-16 23:37:42" itemprop="dateModified" datetime="2025-06-16T23:37:42+08:00">2025-06-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      
          <h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><h3 id="计算树的节点"><a href="#计算树的节点" class="headerlink" title="计算树的节点"></a>计算树的节点</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">// Created by 何晨易 on 2025/5/3.</span><br><span class="line">//</span><br><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">  int data;</span><br><span class="line">  TreeNode *left;</span><br><span class="line">  TreeNode *right;</span><br><span class="line">  TreeNode(): data(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">&#125; treeNode;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">TreeNode *<span class="function"><span class="title">createTreeNode</span></span>()&#123;</span><br><span class="line">    TreeNode *root = new TreeNode();</span><br><span class="line">    root-&gt;left = new TreeNode();</span><br><span class="line">    root-&gt;right = new TreeNode();</span><br><span class="line">    root-&gt;left-&gt;right = new TreeNode();</span><br><span class="line">    root-&gt;left-&gt;left = new TreeNode();</span><br><span class="line">    <span class="built_in">return</span> root;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">void countNodes(TreeNode* node, int&amp; internalCount, int&amp; leafCount)&#123;</span><br><span class="line">  <span class="keyword">if</span>(node == nullptr)&#123;</span><br><span class="line">    <span class="built_in">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(node-&gt;left == nullptr &amp;&amp; node-&gt;right == nullptr)&#123;</span><br><span class="line">    leafCount++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    internalCount++;</span><br><span class="line">  &#125;</span><br><span class="line">  countNodes(node-&gt;left, internalCount, leafCount);</span><br><span class="line">  countNodes(node-&gt;right, internalCount, leafCount);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">    TreeNode *root = createTreeNode();</span><br><span class="line">//      0</span><br><span class="line">//     / \</span><br><span class="line">//    0   0</span><br><span class="line">//   / \</span><br><span class="line">//  0  0</span><br><span class="line">    int internalCount = 0;</span><br><span class="line">    int   leafCount = 0;</span><br><span class="line">    countNodes(root, internalCount, leafCount);</span><br><span class="line">    cout &lt;&lt; <span class="string">internalCount &lt;&lt; endl;</span></span><br><span class="line"><span class="string">    cout &lt;&lt; leafCount &lt;&lt; endl;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>

<p>C++在构建定义结构体的时候，可以如上述代码使用TreeNode(): data(0), left(nullptr), right(nullptr) {}方式来构造。如果不在定义结构体内使用构造函数，那么可以用{}的方式来构造  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct Item&#123;</span><br><span class="line">    string name;</span><br><span class="line">    int w, v, u;</span><br><span class="line">&#125;</span><br><span class="line">int <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">    vector&lt;Item&gt; items = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;Hocker&quot;</span>, 5, 5, 0&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Handy&quot;</span>, 1, 20, 1&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="mergeSort"><a href="#mergeSort" class="headerlink" title="mergeSort"></a>mergeSort</h3><p>使用了<strong>分治</strong>的思想，将数组进行分块，并且每次分块是用二分法来进行划分，划分次数为log2(n)，n为数组长度<br>然后对每次划分得到的两个数组进行合并排序。由于每次合并排序都是对n个数字进行操作，因此时间复杂度为nlog2(n)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">// Created by 何晨易 on 2025/6/14.</span><br><span class="line">//</span><br><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;vector&gt;</span></span><br><span class="line">std::vector&lt;int&gt; merge(std::vector&lt;int&gt;&amp; nums1, std::vector&lt;int&gt;&amp; nums2) &#123;</span><br><span class="line">  int i = 0, j = 0;</span><br><span class="line">  int size1 = nums1.size(), size2 = nums2.size();</span><br><span class="line"></span><br><span class="line">  nums1.push_back(INT_MAX);</span><br><span class="line">  nums2.push_back(INT_MAX);</span><br><span class="line"></span><br><span class="line">  std::vector&lt;int&gt; temp(size1 + size2);</span><br><span class="line">  <span class="keyword">for</span> (int n = 0; n &lt; size1 + size2; ++n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums1[i] &lt; nums2[j]) &#123;</span><br><span class="line">      temp[n] = nums1[i++];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      temp[n] = nums2[j++];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void mergeSort(std::vector&lt;int&gt;&amp; nums, int left, int right) &#123;</span><br><span class="line">  <span class="keyword">if</span>(left &gt;= right)&#123;</span><br><span class="line">    <span class="built_in">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  int mid = left + (right - left) / 2 ;</span><br><span class="line">  mergeSort(nums, left, mid);</span><br><span class="line">  mergeSort(nums, mid + 1, right);</span><br><span class="line"></span><br><span class="line">  std::vector&lt;int&gt; leftarray(nums.begin() + left, nums.begin() + mid + 1);</span><br><span class="line">  std::vector&lt;int&gt; rightarray(nums.begin() + mid + 1, nums.begin() + right + 1);</span><br><span class="line"></span><br><span class="line">  std::vector&lt;int&gt; merged = merge(leftarray, rightarray);</span><br><span class="line">  // 拷贝回原数组</span><br><span class="line">  <span class="keyword">for</span> (int i = 0; i &lt; merged.size(); ++i) &#123;</span><br><span class="line">    nums[left + i] = merged[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">  std::vector&lt;int&gt; nums1 = &#123;1,2,3,4,5,6,7,8,9&#125;;</span><br><span class="line">  std::vector&lt;int&gt; nums2 = &#123;9,10,11,100,200&#125;;</span><br><span class="line">//  std::vector&lt;int&gt; merged = merge(nums1, nums2);</span><br><span class="line">  std::vector&lt;int&gt; nums3 = &#123;3,2,5,1,6&#125;;</span><br><span class="line">  mergeSort(nums3, 0, nums3.size() - 1);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;合并后数组：&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (int num : nums3) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">num &lt;&lt; &quot; &quot;;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  std::cout &lt;&lt; std::endl;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  return 0;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>


<h3 id="heapSort"><a href="#heapSort" class="headerlink" title="heapSort"></a>heapSort</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">// Created by 何晨易 on 2025/6/16.</span><br><span class="line">//</span><br><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;vector&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// 向下堆化（heapify）</span><br><span class="line">void heapify(vector&lt;int&gt;&amp; arr, int n, int i) &#123;</span><br><span class="line">    int largest = i;       // 当前节点索引</span><br><span class="line">    int left = 2 * i + 1;  // 左子节点</span><br><span class="line">    int right = 2 * i + 2; // 右子节点</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left &lt; n &amp;&amp; arr[left] &gt; arr[largest])</span><br><span class="line">        largest = left;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (right &lt; n &amp;&amp; arr[right] &gt; arr[largest])</span><br><span class="line">        largest = right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">        swap(arr[i], arr[largest]);</span><br><span class="line">        heapify(arr, n, largest);  // 递归下沉</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 堆排序</span><br><span class="line">void heapSort(vector&lt;int&gt;&amp; arr) &#123;</span><br><span class="line">    int n = arr.size();</span><br><span class="line"></span><br><span class="line">    // 构建最大堆</span><br><span class="line">    <span class="keyword">for</span> (int i = n / 2 - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">        heapify(arr, n, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 逐个取出最大元素，并重新堆化</span><br><span class="line">    <span class="keyword">for</span> (int i = n - 1; i &gt; 0; i--) &#123;</span><br><span class="line">        swap(arr[0], arr[i]);       // 将当前最大值（堆顶）放到末尾</span><br><span class="line">        heapify(arr, i, 0);         // 对剩余部分进行堆化</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 打印数组</span><br><span class="line">void printArray(const vector&lt;int&gt;&amp; arr) &#123;</span><br><span class="line">    <span class="keyword">for</span> (int val : arr)</span><br><span class="line">        cout &lt;&lt; <span class="string">val &lt;&lt; &quot; &quot;;</span></span><br><span class="line"><span class="string">    cout &lt;&lt; endl;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 测试</span></span><br><span class="line"><span class="string">int main() &#123;</span></span><br><span class="line"><span class="string">    vector&lt;int&gt; arr = &#123;40, 30, 25, 50, 20, 10&#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    cout &lt;&lt; &quot;原始数组: &quot;;</span></span><br><span class="line"><span class="string">    printArray(arr);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    heapSort(arr);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    cout &lt;&lt; &quot;排序后数组: &quot;;</span></span><br><span class="line"><span class="string">    printArray(arr);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>

<h2 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h2><h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><p>可以先计算每一个物品的性价比，也就是价值&#x2F;质量</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://hechenyi.github.io/2025/05/01/%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/05/01/%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B/" class="post-title-link" itemprop="url">随机过程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-05-01 00:51:52" itemprop="dateCreated datePublished" datetime="2025-05-01T00:51:52+08:00">2025-05-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-07-19 14:23:59" itemprop="dateModified" datetime="2025-07-19T14:23:59+08:00">2025-07-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">通信原理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      
          <h2 id="Basic-concept"><a href="#Basic-concept" class="headerlink" title="Basic concept"></a>Basic concept</h2><p>随机过程是随机试验的衍生，具体来说它是Xi(t)的集合，其中Xi是n个变量，理论上n是无强大，Xi的分布函数和t有关，也就是说它的统计学特性受时间影响。</p>
<h3 id="样本函数与概率密度函数（PDF）"><a href="#样本函数与概率密度函数（PDF）" class="headerlink" title="样本函数与概率密度函数（PDF）"></a>样本函数与概率密度函数（PDF）</h3><p>样本函数：随机过程X(t)的一次实现或某个样本路径，记为x(t)，也就是样本函数<br>概率密度函数：在某个时刻t，随机变量X(t)的概率分布密度函数，记为$f(x)$<br>可以这么理解：<br>样本函数：一个人的身高随年龄的变化曲线<br>概率密度：某个年龄段所有人身高的统计分布  </p>
<h3 id="随机过程的均值和自相关函数计算"><a href="#随机过程的均值和自相关函数计算" class="headerlink" title="随机过程的均值和自相关函数计算"></a>随机过程的均值和自相关函数计算</h3><p>$\epsilon(t) &#x3D; Acos(w_ct + \phi)$<br>其中$\phi$在0到2pi上均匀分布<br>$E[\epsilon(t)]&#x3D;\int_{0}^{2\pi}Acos(w_ct+\phi)\frac{1}{2\pi}d_\phi$<br>然后对cos函数进行拆解，把$cos\phi$的部分拆解出来，然后求积分</p>
<h3 id="一维分布函数"><a href="#一维分布函数" class="headerlink" title="一维分布函数"></a>一维分布函数</h3><p>也就是说只考虑某个固定的时间t，随机变量X(t)的分布函数一般与t有关：<br>Fx(x,t) &#x3D; P{X(t)&lt;&#x3D;x}<br>当t取遍T中的所有元素时，我们可以得到一系列的分布函数，将这些分布函数的全体所构成的集合称为一维分布函数族，记为<br>{Fx(x;t)}<br>这个也就是一维分布函数族,它用来刻画随机过程在各个单独时刻的统计特性。</p>
<h3 id="一维随机过程的n维分布函数族"><a href="#一维随机过程的n维分布函数族" class="headerlink" title="一维随机过程的n维分布函数族"></a>一维随机过程的n维分布函数族</h3><p>一维分布函数族刻画了随机过程在各个时刻的统计特征，为了描述随机过程在<strong>不同时刻状态之间的统计联系</strong>，一般可对任意<br> 个不同的时刻，也就是可以用二维分布函数来表示，如下分布函数所示：   </p>
<img src="/images/一维随机过程.png"> 

<p>这个分布函数是关于t1 t2 x1 x2四个变量的函数。<br>例如当t1&#x3D;1，x1&#x3D;1；t2&#x3D;1，x2&#x3D;1的时候P( x(t&#x3D;1)&lt;1 , x(t&#x3D;2)&lt;1 ) 的取值，<br>对比前面的1维分布函数，后者例如t1&#x3D;1，x1&#x3D;1时候，P（ x（t&#x3D;1）&lt;1）的取值<br><strong>n维</strong>分布函数：为了描述随机过程在不同时刻状态之间的关系，对任意n个不同时刻t1，t2，…,tn引入n维随机变量<br>（X（t1）， X（t2）， X（t3），…, X（tn））的分布函数</p>
<h3 id="平稳随机过程"><a href="#平稳随机过程" class="headerlink" title="平稳随机过程"></a>平稳随机过程</h3><p>平稳随机过程的统计特性不随时间的推移而变化，其一维分布与时间t无关，二维分布只与时间间隔$\tau$有关，如下</p>
<ul>
<li>一维分布与时间$\tau$无关<br>f(x,t) &#x3D; f(x)</li>
<li>二维分布只与时间间隔$\tau$有关<br>f(x1,x2;t1,t2) &#x3D; f(x1,x2;τ)</li>
</ul>
<h4 id="平稳随机过程的数字特征"><a href="#平稳随机过程的数字特征" class="headerlink" title="平稳随机过程的数字特征"></a>平稳随机过程的数字特征</h4><ul>
<li>自相关只与时间间隔$\tau$有关，而与时间起点无关<br>R(0) &#x3D; E[ $\epsilon^2(t)$ ] &#x3D; S （也称为均方值）<br>同时平均功率E根据定义如下式所示：<br>S &#x3D; $\int_{-\infty}^{\infty}P_n(f)d_f$  &#x3D;  $\frac{1}{2\pi}\int_{-\infty}^{\infty}P_n(w)d_w$<br>因此平均功率S有以上两种求法</li>
</ul>
<p>物理意义： 随机过程的平均功率    </p>
<ul>
<li><p>均值<br>均值与t无关，样本函数围绕一水平线起伏<br>也就是$E[\epsilon(t)] &#x3D; \mu$.<br>因此$P &#x3D; \lim_{T \to \infty} \frac{1}{2T}\int_{-T}^{T}E[\epsilon(t)^2]dt &#x3D; E[\epsilon(t)^2]$</p>
</li>
<li><p>方差。</p>
</li>
</ul>
<p>方差与t无关，为常数</p>
<p>R($\infty$) &#x3D; E[$\epsilon$(t)]²<br>因为时间间隔无限大时，$\epsilon(t)$ 与 $\epsilon(t+\tau)$趋于独立</p>
<p>物理意义： 随机过程的直流功率</p>
<h4 id="平稳随机过程的功率谱密度"><a href="#平稳随机过程的功率谱密度" class="headerlink" title="平稳随机过程的功率谱密度"></a>平稳随机过程的功率谱密度</h4><p>假定f(t)为随机过程$\epsilon(t)$的任意实现，对其进行T长度的截断，并在对其进行傅立叶变换。<br>$\lim_{T \to \infty} \frac{|F_T(w)|^2}{T}$</p>
<p><strong>维纳-辛钦定律</strong><br>平稳随机过程$\epsilon(t)$的功率谱密度函数$P_\epsilon(w)$和自相关函数R($\tau$)为一对傅立叶变换对<br><img src="/images/功率谱密度.png"></p>
<p><strong>平均功率计算方法</strong>:<br>S &#x3D; R(0) &#x3D; E[$\epsilon(t)^2$]<br>S &#x3D; $\frac{1}{2\pi}\int_{-\infty}^{\infty}P_\epsilon(w),dw$</p>
<h4 id="平稳随机过程的各态历经性"><a href="#平稳随机过程的各态历经性" class="headerlink" title="平稳随机过程的各态历经性"></a>平稳随机过程的各态历经性</h4><p>时间均值公式：<br>$\overline{x} &#x3D; \lim_{T \to \infty} \frac{1}{2T} \int_{-T}^{T} x(t) , dt$<br>若平稳随机过程的时间均值$\overline{x}$ &#x3D; E(x)，那么其具有各态历经性  </p>
<hr>
<blockquote>
<p><strong>Notice</strong><br><br>在求随机过程的功率时，使用其平方的数学期望来进行计算，而非其时间均值，除非是在满足各态历经性的前提下</p>
</blockquote>
<hr>
<h3 id="高斯随机过程"><a href="#高斯随机过程" class="headerlink" title="高斯随机过程"></a>高斯随机过程</h3><p>若随机过程的任意<strong>n</strong>维分布都是正态分布，则称它为高斯随机过程或正态过程。其n维概率密度函数为：<br>$f_a(x_1,x_2,…;t_1,…,t_n)$<br>一维高斯过程的概率密度函数：<br>X ~ N(a,$\sigma^2$)<br>$f_1(x)$ &#x3D; $\frac{1}{\sqrt{(2\pi)}\sigma}exp[-\frac{(x-a)^2}{2\sigma^2}]$<br>高斯过程在不同时刻取值不相关，则它们也统计独立。<br>高斯过程经过线性变化（或线性系统）后仍为高斯过程。</p>
<h4 id="正态分布函数"><a href="#正态分布函数" class="headerlink" title="正态分布函数"></a>正态分布函数</h4><p>先来看正态概率密度函数<br>X ～ N(a,$\sigma^2$),<br>$f_1(x)$ &#x3D; $\frac{1}{\sqrt{(2\pi)}\sigma}exp[-\frac{(x-a)^2}{2\sigma^2}]$<br>那么正态分布函数就是将上述函数从负无穷到x上积分<br>标准&#x2F;归一化的正态分布是另a&#x3D;0，$\sigma$&#x3D;1<br>$f_1(x) &#x3D; \frac{1}{\sqrt{(2\pi)}}exp[-\frac{x^2}{2}]$  </p>
<h4 id="Q函数"><a href="#Q函数" class="headerlink" title="Q函数"></a>Q函数</h4><p>和正态分布的密度分布函数是互补的关系<br>也就是从x到正无穷积分（正态分布函数是从负无穷到x积分）</p>
<h4 id="误差函数"><a href="#误差函数" class="headerlink" title="误差函数"></a>误差函数</h4><p>$\text{erf}(x) &#x3D; \frac{2}{\sqrt{\pi}} \int_{0}^{x} e^{-t^2} , dt$<br>互补误差函数和它互补，也就是说是从x到正无穷上积分<br>误差函数、互补误差函数与正态分布函数存在一个关系<br><img src="/images/误差函数.png"></p>
<h3 id="随机过程通过线性系统"><a href="#随机过程通过线性系统" class="headerlink" title="随机过程通过线性系统"></a>随机过程通过线性系统</h3><img src="/images/随机过程通过线性系统.png">  

<p>有以下几个特性  </p>
<ul>
<li><p>数学期望<br>E[$\epsilon_o(t)$] &#x3D; aH(0)</p>
</li>
<li><p>自相关函数<br>输入平稳随机过程，则输出过程自相关函数只与时间间隔有关</p>
</li>
</ul>
<hr>
<blockquote>
<p><strong>Notice</strong><br><br>平稳随机过程通过线性系统，输出也是平稳随机过程</p>
</blockquote>
<hr>
<ul>
<li>功率谱密度<br>$P_o(w)$&#x3D;$P_i(w)$|$H(w)^2$|<br>其中|$H(w)^2$|为功率增益</li>
</ul>
<h3 id="窄带随机过程"><a href="#窄带随机过程" class="headerlink" title="窄带随机过程"></a>窄带随机过程</h3><p>窄带系统要求通带宽度$\Delta f \ll f_c$<br>窄带过程是指随机过程通过以$f_c$为中心频率的窄带系统的输出过程<br>$$<br>\xi(t) &#x3D; A(t) \cos\big(2\pi f_c t + \phi(t)\big)<br>$$</p>
<ul>
<li>$\xi(t)$：窄带随机过程的样本函数</li>
<li>A(t)：随机包络（幅度调制过程）  </li>
<li>$f_c$：载波频率（中心频率）  </li>
<li>$\phi(t)$：随机相位</li>
</ul>
<p>可以将其写成同相分量加上正交分量的形式<br>$\xi(t) &#x3D; \xi_c(t)cosw_ct - \xi_s(t)sinw_ct$<br>其中同相分量$\xi_c(t)$和正交分量$\xi_s(t)$以及$\xi(t)$的统计特性都一样，也就是数学期望和方差都一样，因此其均方值也一样，也就是平均功率都一样</p>
<img src="/images/窄带过程.png">  
通常分析平稳高斯窄带过程$\xi(t)$  
所以均值为0，方差为$\sigma^2$,由于可以写成同向分量$\sigma_c(t)$与正交分量$\sigma_s(t)$线性组合的关系，因此这两个分量的数学期望也均为0，并且二者都平稳（相关函数均只与时间间隔有关），并且二者的自相关函数相同，方差相同，同时也互不相关、统计独立的高斯变量。
简单来讲， 这两个分量为零均值、等方差、不相关、独立的平稳高斯过程。 

<h3 id="正弦波加窄带高斯过程"><a href="#正弦波加窄带高斯过程" class="headerlink" title="正弦波加窄带高斯过程"></a>正弦波加窄带高斯过程</h3><p>$r(t) &#x3D; Acos(\omega_c t + \phi) + n(t)$<br>其中n(t)是均值为0，方差为$\sigma^2$的窄带高斯噪声<br>然后通过三角函数转换可得r(t)最终也可以分解为同相分量和正交向量，也就是$z_c(t) &#x3D; Acos{\phi} + n_c(t)$和$z_s(t) &#x3D; Acos{\phi} + n_s(t)$<br><img src="随机包络随机相位.png"><br>随机包络遵循广义瑞利分布，随机相位的概率密度与信噪比环境有关。<br>对于小信噪比环境，它们分布退化为瑞利分布和均匀分布。<br>同时它们的整体，也就是正弦波+窄带高斯过程会退化为窄带高斯过程。</p>
<h3 id="白噪声"><a href="#白噪声" class="headerlink" title="白噪声"></a>白噪声</h3><p>功率谱密度均匀分布在整个频率范围内的随机过程称为白噪声<br>由自相关和功率谱密度的傅立叶变换关系可知，白噪声的自相关函数是在$\tau$&#x3D;0上面有个冲激信号的函数</p>
<h3 id="高斯白噪声"><a href="#高斯白噪声" class="headerlink" title="高斯白噪声"></a>高斯白噪声</h3><p>服从高斯分布的白噪声，在任意两个不同时刻上随机变量互不相关，且统计独立。</p>
<h3 id="低通白噪声"><a href="#低通白噪声" class="headerlink" title="低通白噪声"></a>低通白噪声</h3><p>功率谱是门函数，对应的自相关函数是sinc函数</p>
<h3 id="带通白噪声"><a href="#带通白噪声" class="headerlink" title="带通白噪声"></a>带通白噪声</h3><p>功率是门函数与两个冲激函数的卷积，对应的傅立叶变换是sinc函数与cos函数的乘积</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://hechenyi.github.io/2025/04/29/LMMSE-base-channel-estimation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/04/29/LMMSE-base-channel-estimation/" class="post-title-link" itemprop="url">LMMSE base channel estimation</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-04-29 00:45:01" itemprop="dateCreated datePublished" datetime="2025-04-29T00:45:01+08:00">2025-04-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-08-04 21:37:05" itemprop="dateModified" datetime="2025-08-04T21:37:05+08:00">2025-08-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/5G/" itemprop="url" rel="index"><span itemprop="name">5G</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      
          <h2 id="Basic-Concept"><a href="#Basic-Concept" class="headerlink" title="Basic Concept"></a>Basic Concept</h2><p>先了解MMSE，MMSE（Minimum Mean Square Error），也就是最小均方误差，是一种常用的统计估计方法，它的目标就是最小化估计值与实际值之间的均方误差（MSE）。在通信系统中，MMSE被广泛用于信道估计，因为它能够在噪声和干扰的影响下，给出一个最优估计。<br>另外，在信道估计中，交叉相关矩阵通常用于计算数据子载波和导频子载波之间的相关性，这对于估计信道的状态至关重要。</p>
<h2 id="数学公式推导"><a href="#数学公式推导" class="headerlink" title="数学公式推导"></a>数学公式推导</h2><h1 id="OFDM-System-Simulation-with-LMMSE-Channel-Estimation"><a href="#OFDM-System-Simulation-with-LMMSE-Channel-Estimation" class="headerlink" title="OFDM System Simulation with LMMSE Channel Estimation"></a>OFDM System Simulation with LMMSE Channel Estimation</h1><p>This MATLAB project simulates an OFDM system using <strong>LMMSE (Linear Minimum Mean Square Error)</strong> channel estimation over a <strong>frequency-selective Rayleigh fading channel</strong>. The system uses QPSK modulation and pilot symbols to perform accurate channel estimation in the frequency domain.</p>
<hr>
<h2 id="📌-Features"><a href="#📌-Features" class="headerlink" title="📌 Features"></a>📌 Features</h2><ul>
<li>QPSK modulation  </li>
<li>Rayleigh fading multipath channel  </li>
<li>AWGN noise  </li>
<li>LMMSE-based pilot-aided channel estimation (PACE)  </li>
<li>Bit Error Rate (BER) analysis</li>
</ul>
<hr>
<h2 id="🧠-Theoretical-Background"><a href="#🧠-Theoretical-Background" class="headerlink" title="🧠 Theoretical Background"></a>🧠 Theoretical Background</h2><h3 id="1-OFDM-Signal-Model"><a href="#1-OFDM-Signal-Model" class="headerlink" title="1. OFDM Signal Model"></a>1. OFDM Signal Model</h3><p>The received signal on subcarrier ( k ) is:</p>
<p>$$<br>Y[k] &#x3D; H[k] \cdot X[k] + W[k]<br>$$</p>
<p>Where:</p>
<p>$$<br>X[k]: \text{ Transmitted signal on subcarrier } k \<br>H[k]: \text{ Channel frequency response at subcarrier } k \<br>W[k]: \text{ Additive white Gaussian noise (AWGN)} \<br>Y[k]: \text{ Received signal at subcarrier } k<br>$$</p>
<hr>
<h3 id="2-LMMSE-Channel-Estimation"><a href="#2-LMMSE-Channel-Estimation" class="headerlink" title="2. LMMSE Channel Estimation"></a>2. LMMSE Channel Estimation</h3><p>The LMMSE estimate of the channel at data subcarriers is:</p>
<p>$$<br>\hat{H}<em>{\text{data}} &#x3D; R</em>{hd,hp} \left( R_{hp,hp} + \sigma^2 (X X^H)^{-1} \right)^{-1} \hat{H}_{\text{pilot}}<br>$$</p>
<p>Where:</p>
<p>$$<br>R_{hd,hp}: \text{ Cross-correlation matrix between data and pilot subcarriers} \<br>R_{hp,hp}: \text{ Autocorrelation matrix of pilot subcarriers} \<br>\hat{H}_{\text{pilot}}: \text{ LS-estimated channel at pilot positions} \<br>\sigma^2: \text{ Noise variance} \<br>X: \text{ Diagonal matrix of known pilot symbols}<br>$$</p>
<hr>
<h3 id="3-Channel-Frequency-Response-DFT"><a href="#3-Channel-Frequency-Response-DFT" class="headerlink" title="3. Channel Frequency Response (DFT)"></a>3. Channel Frequency Response (DFT)</h3><p>The time-domain convolution is，这也是一个离散时间的线性卷积公式，它描述了<strong>多径信道</strong>(多径效应)对时域基带信号的影响，其中每一个h[l]表示不同时间延迟下的路径增益:</p>
<hr>
<blockquote>
<p><strong>Notice</strong><br><br>引入OFDM可以抗多径，因为在循环前缀CP足够长的条件下，把时域的多径线性卷积变换为<strong>循环卷积</strong>,也就是Y[k] &#x3D; H[k]X[k] + W[k]<br></p>
</blockquote>
<hr>
<p>$$<br>y[n] &#x3D; \sum_{m&#x3D;0}^{L-1} h[m] \cdot x[n - m]<br>$$</p>
<p>The corresponding channel frequency response is obtained via DFT:</p>
<p>$$<br>H[k] &#x3D; \sum_{l&#x3D;0}^{L-1} h[l] \cdot e^{-j \frac{2\pi k l}{N}}<br>$$</p>
<p>Where:</p>
<p>$$<br>h[l]: \text{ Channel tap in time domain} \<br>N: \text{ FFT length (number of subcarriers)} \<br>k: \text{ Subcarrier index}<br>$$</p>
<hr>
<h3 id="4-Calculation-of-R-hp-hp"><a href="#4-Calculation-of-R-hp-hp" class="headerlink" title="4. Calculation of $R_{hp,hp}$"></a>4. Calculation of $R_{hp,hp}$</h3><p>在统计通信理论中，如果H[i]是频率索引为i的频域信道系数（例如OFDM中第i个子载波的信道响应）<br>$R_H(i,j)&#x3D;E[H[i]H[j]]$<br>To calculate the autocorrelation matrix between pilot subcarriers $R_{hp,hp}$, we start from the frequency-domain channel representation. The channel frequency response at subcarrier ( n ) is given by the discrete Fourier transform (DFT) of the time-domain channel taps:</p>
<p>$$<br>H[n] &#x3D; \sum_{l&#x3D;0}^{L-1} h[l] e^{-j \frac{2\pi}{N} n l}<br>$$</p>
<p>where:</p>
<ul>
<li>( L ) is the number of channel taps,</li>
<li>( h[l] ) is the complex channel coefficient of the ( l )-th tap,</li>
<li>( N ) is the FFT length,</li>
<li>( n ) is the subcarrier index.</li>
</ul>
<p>The autocorrelation between frequency responses at pilot subcarrier indices ( n_i ) and ( n_j ) is:</p>
<p>$$<br>\begin{aligned}<br>R_{hp,hp}(i,j) &amp;&#x3D; E \left[ H[n_i] H^<em>[n_j] \right] \<br>&amp;&#x3D; E \left[ \left( \sum_{l&#x3D;0}^{L-1} h[l] e^{-j \frac{2\pi}{N} n_i l} \right) \left( \sum_{m&#x3D;0}^{L-1} h[m] e^{-j \frac{2\pi}{N} n_j m} \right)^</em> \right] \<br>&amp;&#x3D; \sum_{l&#x3D;0}^{L-1} \sum_{m&#x3D;0}^{L-1} e^{-j \frac{2\pi}{N} n_i l} e^{j \frac{2\pi}{N} n_j m} E \left[ h[l] h^*[m] \right]<br>\end{aligned}<br>$$</p>
<p>Assuming that the channel taps are uncorrelated with power delay profile $\sigma_l^2 &#x3D; E[|h[l]|^2]$, we have:</p>
<p>$$<br>E \left[ h[l] h^*[m] \right] &#x3D;<br>\begin{cases}<br>\sigma_l^2, &amp; l &#x3D; m \<br>0, &amp; l \neq m<br>\end{cases}<br>$$</p>
<p>Thus, the autocorrelation matrix element simplifies to:</p>
<p>$$<br>R_{hp,hp}(i,j) &#x3D; \sum_{l&#x3D;0}^{L-1} \sigma_l^2 e^{-j \frac{2\pi}{N} (n_i - n_j) l}<br>$$</p>
<p>This formula describes the correlation between frequency-domain channel coefficients at pilot positions ( n_i ) and ( n_j ), derived from the time-domain power delay profile.</p>
<hr>
<h3 id="5-Calculation-of-R-hd-hp"><a href="#5-Calculation-of-R-hd-hp" class="headerlink" title="5. Calculation of $R_{hd,hp}$"></a>5. Calculation of $R_{hd,hp}$</h3><p>计算过程和计算导频之间的互相关函数一样，只是需要注意data部分的索引。</p>
<h2 id="📁-File-Structure"><a href="#📁-File-Structure" class="headerlink" title="📁 File Structure"></a>📁 File Structure</h2><ul>
<li><code>ofdm_lmmse_sim.m</code> – Main simulation script  </li>
<li><code>Gen_autocorr.m</code> – Generates channel autocorrelation values  </li>
<li><code>README.md</code> – Project documentation</li>
</ul>
<hr>
<h2 id="⚙️-Key-Parameters"><a href="#⚙️-Key-Parameters" class="headerlink" title="⚙️ Key Parameters"></a>⚙️ Key Parameters</h2><table>
<thead>
<tr>
<th>Parameter</th>
<th>Value</th>
</tr>
</thead>
<tbody><tr>
<td>FFT Length</td>
<td>256</td>
</tr>
<tr>
<td>Pilot Count</td>
<td>32</td>
</tr>
<tr>
<td>Channel Taps</td>
<td>10</td>
</tr>
<tr>
<td>Cyclic Prefix</td>
<td>9</td>
</tr>
<tr>
<td>SNR</td>
<td>40 dB</td>
</tr>
<tr>
<td>Modulation</td>
<td>QPSK</td>
</tr>
<tr>
<td>Simulation Frames</td>
<td>1000</td>
</tr>
</tbody></table>
<hr>
<h2 id="CSI-Acquisition-and-Precoding-Impact-on-BER"><a href="#CSI-Acquisition-and-Precoding-Impact-on-BER" class="headerlink" title="CSI Acquisition and Precoding Impact on BER"></a>CSI Acquisition and Precoding Impact on BER</h2><p>In MIMO-OFDM systems, accurate Channel State Information (CSI) is essential for leveraging spatial multiplexing gains and optimizing transmission through precoding:</p>
<ul>
<li><strong>Channel Sounding:</strong> Known pilot or preamble sequences are transmitted to probe the channel. The receiver estimates the CSI (\hat{H}) using LMMSE or similar methods.  </li>
<li><strong>CSI Feedback &amp; Precoding:</strong> The estimated CSI is fed back to the transmitter, which computes a precoding matrix ( \mathbf{V} ) (e.g., based on SVD or LMMSE estimation) to pre-multiply data symbols. This precoding enhances signal quality and mitigates interference.  </li>
<li><strong>Data Transmission &amp; BER:</strong> The precoded data is transmitted through the MIMO channel. The receiver decodes the signals based on the estimated CSI. The accuracy of CSI directly affects Bit Error Rate (BER) performance — better CSI leads to lower BER.</li>
</ul>
<p>Example MATLAB snippet for per-subcarrier precoding:</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> carrIdx = <span class="number">1</span>:prm.numCarriers</span><br><span class="line">    Q = <span class="built_in">squeeze</span>(v(carrIdx,:,:));</span><br><span class="line">    normQ = Q * <span class="built_in">sqrt</span>(numTx)/norm(Q,<span class="string">&#x27;fro&#x27;</span>);</span><br><span class="line">    preData(carrIdx,symIdx,:) = <span class="built_in">squeeze</span>(gridData(carrIdx,symIdx,:)).&#x27; * normQ;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Deep-Learning-for-CSI-Prediction"><a href="#Deep-Learning-for-CSI-Prediction" class="headerlink" title="Deep Learning for CSI Prediction"></a>Deep Learning for CSI Prediction</h3><h4 id="Objective"><a href="#Objective" class="headerlink" title="Objective"></a>Objective</h4><p>Use a neural network to predict CSI vectors from the received LTF sequences instead of using LMMSE.</p>
<h4 id="Model-Architecture-Keras"><a href="#Model-Architecture-Keras" class="headerlink" title="Model Architecture (Keras)"></a>Model Architecture (Keras)</h4><ul>
<li>Fully Connected Neural Network (FC或MLP)</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> args.model == <span class="string">&#x27;FC&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;now the model is Full Dense Model&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> args.datasource == <span class="string">&#x27;matlab_maMimo&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> args.decimate_max:</span><br><span class="line">            decimate = Flatten()(MaxPooling1D()(next_layer_in))</span><br><span class="line">            next_layer_in = Concatenate(axis=1)([decimate, seq_p])</span><br><span class="line">        <span class="keyword">elif</span> args.decimate_avg:</span><br><span class="line">            decimate = Flatten()(AveragePooling1D()(next_layer_in))</span><br><span class="line">            next_layer_in = Concatenate(axis=1)([decimate, seq_p])</span><br><span class="line">        <span class="comment"># TODO aggiungere decimazione pura (senza max o avg pooling, solo scarto)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            flatten = Flatten()(next_layer_in)</span><br><span class="line">            next_layer_in = Concatenate(axis=1)([flatten, seq_p])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, n <span class="keyword">in</span> enumerate(nn):</span><br><span class="line">        layers[<span class="string">&#x27;dense&#x27;</span>].append(</span><br><span class="line">            Dense(nn[i], activation=<span class="string">&#x27;relu&#x27;</span>, kernel_initializer=<span class="string">&#x27;glorot_uniform&#x27;</span>, name=<span class="string">&#x27;fc_dense&#x27;</span>+str(i))(next_layer_in)</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">if</span> args.useBN:</span><br><span class="line">            layers[<span class="string">&#x27;batchnorm&#x27;</span>].append(</span><br><span class="line">                BatchNormalization()(layers[<span class="string">&#x27;dense&#x27;</span>][-1])</span><br><span class="line">            )</span><br><span class="line">            next_layer_in = layers[<span class="string">&#x27;batchnorm&#x27;</span>][-1]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            next_layer_in = layers[<span class="string">&#x27;dense&#x27;</span>][-1]</span><br><span class="line">        <span class="keyword">if</span> (i &lt; (numDense - 1)) and (args.dropout != 0.0):  <span class="comment"># if not the last layer, add dropout</span></span><br><span class="line">            layers[<span class="string">&#x27;dropout&#x27;</span>].append(</span><br><span class="line">                Dropout(args.dropout, name=<span class="string">&#x27;drop&#x27;</span>+str(i))(next_layer_in)</span><br><span class="line">            )</span><br><span class="line">            next_layer_in = layers[<span class="string">&#x27;dropout&#x27;</span>][-1]</span><br><span class="line">    encoder = Dense(simParams[<span class="string">&#x27;nSubCarr&#x27;</span>], activation=<span class="string">&#x27;linear&#x27;</span>, kernel_initializer=<span class="string">&#x27;glorot_uniform&#x27;</span>, name=<span class="string">&#x27;fc_regressor&#x27;</span>)(next_layer_in)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> args.datasource == <span class="string">&#x27;matlab_maMimo&#x27;</span>:</span><br><span class="line">        CSI_predictor = Model([seq_in,seq_p], encoder)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        CSI_predictor = Model(seq_in, encoder)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其中隐藏层nn数列为[1024,1024],因此最后的模型summary为：</p>
<table>
<thead>
<tr>
<th>Layer Name</th>
<th>Type</th>
<th>Output Shape</th>
<th>Parameters</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>seq_in</code></td>
<td>Input</td>
<td><code>(None, T, F)</code></td>
<td>0</td>
<td>CSI time-series input</td>
</tr>
<tr>
<td><code>seq_p</code></td>
<td>Input</td>
<td><code>(None, P)</code></td>
<td>0</td>
<td>Position input</td>
</tr>
<tr>
<td><code>flatten</code></td>
<td>Flatten</td>
<td><code>(None, T×F)</code></td>
<td>0</td>
<td>Flattens CSI sequence</td>
</tr>
<tr>
<td><code>concatenate</code></td>
<td>Concatenate</td>
<td><code>(None, T×F + P)</code></td>
<td>0</td>
<td>Merges CSI and position inputs</td>
</tr>
<tr>
<td><code>fc_dense0</code></td>
<td>Dense</td>
<td><code>(None, 1024)</code></td>
<td><code>(T×F + P + 1) × 1024</code></td>
<td>Fully connected layer with ReLU</td>
</tr>
<tr>
<td><code>batch_norm_0</code></td>
<td>BatchNorm</td>
<td><code>(None, 1024)</code></td>
<td>4096</td>
<td>Batch normalization</td>
</tr>
<tr>
<td><code>drop0</code></td>
<td>Dropout</td>
<td><code>(None, 1024)</code></td>
<td>0</td>
<td>Dropout layer (optional)</td>
</tr>
<tr>
<td><code>fc_dense1</code></td>
<td>Dense</td>
<td><code>(None, 1024)</code></td>
<td><code>1024 × 1024 + 1024 = 1,049,600</code></td>
<td>Hidden dense layer</td>
</tr>
<tr>
<td><code>batch_norm_1</code></td>
<td>BatchNorm</td>
<td><code>(None, 1024)</code></td>
<td>4096</td>
<td>Batch normalization</td>
</tr>
<tr>
<td><code>fc_regressor</code></td>
<td>Dense</td>
<td><code>(None, nSubCarr)</code></td>
<td><code>1024 × nSubCarr + nSubCarr</code></td>
<td>Output prediction (e.g., CSI subcarriers)</td>
</tr>
</tbody></table>
<ul>
<li>CNN</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">elif</span> args.model ==<span class="string">&#x27;CONV1D&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;now the model is Convolution 1D Model&quot;</span>)</span><br><span class="line"></span><br><span class="line">    conv1 = BatchNormalization()(Conv1D(128, 7, padding=<span class="string">&#x27;same&#x27;</span>, name=<span class="string">&#x27;cnn1d_1&#x27;</span>, activation=<span class="string">&#x27;relu&#x27;</span>)(next_layer_in))</span><br><span class="line">    maxpool1 = AveragePooling1D()(conv1)</span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    conv2 = BatchNormalization()(Conv1D(64, 7, padding=&#x27;same&#x27;, name=&#x27;cnn1d_2&#x27;, activation=&#x27;relu&#x27;)(maxpool1))</span></span><br><span class="line"><span class="string">    maxpool2 = AveragePooling1D()(conv2)</span></span><br><span class="line"><span class="string">   </span></span><br><span class="line"><span class="string">    conv3 = BatchNormalization()(Conv1D(64, 5, padding=&#x27;same&#x27;, name=&#x27;cnn1d_3&#x27;, activation=&#x27;relu&#x27;)(maxpool2))</span></span><br><span class="line"><span class="string">    maxpool3 = MaxPooling1D()(conv3)</span></span><br><span class="line"><span class="string">    &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">    flatten = Flatten()(maxpool1)</span><br><span class="line">    <span class="comment"># TODO INSERT CONVOLUTIONAL AUTOENCODER HERE</span></span><br><span class="line"></span><br><span class="line">    next_layer_in = Concatenate(axis=1)([flatten, seq_p])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, n <span class="keyword">in</span> enumerate(nn):</span><br><span class="line">        layers[<span class="string">&#x27;dense&#x27;</span>].append(</span><br><span class="line">            Dense(nn[i], activation=<span class="string">&#x27;relu&#x27;</span>, kernel_initializer=<span class="string">&#x27;glorot_uniform&#x27;</span>, name=<span class="string">&#x27;fc_dense&#x27;</span>+str(i))(next_layer_in)</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">if</span> args.useBN:</span><br><span class="line">            layers[<span class="string">&#x27;batchnorm&#x27;</span>].append(</span><br><span class="line">                BatchNormalization()(layers[<span class="string">&#x27;dense&#x27;</span>][-1])</span><br><span class="line">            )</span><br><span class="line">            next_layer_in = layers[<span class="string">&#x27;batchnorm&#x27;</span>][-1]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            next_layer_in = layers[<span class="string">&#x27;dense&#x27;</span>][-1]</span><br><span class="line">        <span class="keyword">if</span> i &lt; (numDense - 1):  <span class="comment"># if not the last layer, add dropout</span></span><br><span class="line">            layers[<span class="string">&#x27;dropout&#x27;</span>].append(</span><br><span class="line">                Dropout(args.dropout, name=<span class="string">&#x27;drop&#x27;</span>+str(i))(next_layer_in)</span><br><span class="line">            )</span><br><span class="line">            next_layer_in = layers[<span class="string">&#x27;dropout&#x27;</span>][-1]</span><br><span class="line">    encoder = Dense(n_out, activation=<span class="string">&#x27;linear&#x27;</span>, kernel_initializer=<span class="string">&#x27;glorot_uniform&#x27;</span>, name=<span class="string">&#x27;fc_regressor&#x27;</span>)(next_layer_in)</span><br><span class="line"></span><br><span class="line">    CSI_predictor = Model([seq_in,seq_p], encoder)</span><br></pre></td></tr></table></figure>
<p>模型的summary如下：</p>
<table>
<thead>
<tr>
<th>Layer Name</th>
<th>Layer Type</th>
<th>Output Shape</th>
<th>Number of Parameters</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>seq_in</td>
<td>InputLayer</td>
<td>(None, T, F)</td>
<td>0</td>
<td>Input CSI sequence</td>
</tr>
<tr>
<td>cnn1d_1</td>
<td>Conv1D</td>
<td>(None, T, 128)</td>
<td>(F * 7 * 128) + 128</td>
<td>1D convolution, kernel size 7, 128 filters</td>
</tr>
<tr>
<td>batch_normalization</td>
<td>BatchNormalization</td>
<td>(None, T, 128)</td>
<td>512</td>
<td>Normalization after conv1d</td>
</tr>
<tr>
<td>average_pooling1d</td>
<td>AveragePooling1D</td>
<td>(None, T&#x2F;&#x2F;2, 128)</td>
<td>0</td>
<td>Downsampling by average pooling</td>
</tr>
<tr>
<td>flatten</td>
<td>Flatten</td>
<td>(None, (T&#x2F;&#x2F;2) * 128)</td>
<td>0</td>
<td>Flatten pooled feature maps</td>
</tr>
<tr>
<td>seq_p</td>
<td>InputLayer</td>
<td>(None, P)</td>
<td>0</td>
<td>Additional parameter input (e.g., position)</td>
</tr>
<tr>
<td>concatenate</td>
<td>Concatenate</td>
<td>(None, (T&#x2F;&#x2F;2)*128 + P)</td>
<td>0</td>
<td>Concatenate flattened features and params</td>
</tr>
<tr>
<td>fc_dense0</td>
<td>Dense</td>
<td>(None, 1024)</td>
<td>((T&#x2F;&#x2F;2)*128 + P + 1) * 1024</td>
<td>Fully connected layer with 1024 units</td>
</tr>
<tr>
<td>batch_normalization_1</td>
<td>BatchNormalization</td>
<td>(None, 1024)</td>
<td>4096</td>
<td>Normalization after fc_dense0</td>
</tr>
<tr>
<td>drop0</td>
<td>Dropout</td>
<td>(None, 1024)</td>
<td>0</td>
<td>Dropout for regularization</td>
</tr>
<tr>
<td>fc_dense1</td>
<td>Dense</td>
<td>(None, 1024)</td>
<td>1,049,600 (1024*1024 + 1024)</td>
<td>Fully connected layer with 1024 units</td>
</tr>
<tr>
<td>batch_normalization_2</td>
<td>BatchNormalization</td>
<td>(None, 1024)</td>
<td>4096</td>
<td>Normalization after fc_dense1</td>
</tr>
<tr>
<td>drop1</td>
<td>Dropout</td>
<td>(None, 1024)</td>
<td>0</td>
<td>Dropout for regularization</td>
</tr>
<tr>
<td>fc_re</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<hr>
<blockquote>
<p><strong>Notice</strong><br><br>需要注意这里的T就是inPreamble，因此在取卷积后output shape为(T,128)，其中128为通道数<br></p>
</blockquote>
<hr>
<p>Output:</p>
<ul>
<li>Predicted CSI of shape $n_{Rx} \times n_{Tx} \times n_{SubCarriers}$</li>
</ul>
<h4 id="Loss"><a href="#Loss" class="headerlink" title="Loss"></a>Loss</h4><p>The model minimizes <strong>MSE</strong> between predicted CSI and ground truth:</p>
<p>$$<br>\text{MSE} &#x3D; \frac{1}{N} \sum_{i&#x3D;1}^{N} \left| H_i - \hat{H}_i \right|^2<br>$$</p>
<p>Also supports NMSE:</p>
<p>$$<br>\text{NMSE} &#x3D; \frac{| H - \hat{H} |^2}{| H |^2}<br>$$<br>这里的$\hat{H}$是通过LMMSE计算得到的，因此是将传统信道估计方法得到的CSI作为ground truth，也就是target</p>
<h4 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h4><h5 id="数据生成"><a href="#数据生成" class="headerlink" title="数据生成"></a>数据生成</h5><ul>
<li>generate_maMIMO_LTF.m</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> [mean_ber] = generate_maMIMO_LTF(exp_ID, numPackets, numBSTx, numUERx, snr_dB_CS, isOnlyCSI, saveFlag, isPlotting, prm, isMMSE)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">usr_data = cell(prm.numUsers, 3);</span><br><span class="line"><span class="keyword">for</span> p = 1 : numPackets:</span><br><span class="line">    <span class="keyword">for</span> nUser = 1:prm.numUsers:</span><br><span class="line">        /// preambleSig的维度 = (FFTLength + CyclicPrefixLength) * numSTS</span><br><span class="line">        /// numSTS = numTx</span><br><span class="line">        preambleSig = helperGenPreamble(prm);</span><br><span class="line">        /// rxPreSig的维度 = numRx x numPreambleSig</span><br><span class="line">        [rxPreSig,chanDelay,h_tau,h_response] = helperApplyMUChannel(preambleSig,prm,spLoss,N_chan_taps,p);</span><br><span class="line">        ...</span><br><span class="line">        usr_data&#123;nUser, 1&#125; = [];</span><br><span class="line">        usr_data&#123;nUser, 2&#125; = [];</span><br><span class="line">        usr_data&#123;nUser, 3&#125; = [];</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>nRxAts x nTxAts x nPackets表示n个样本，按照batch_size从中取样，放到X和y中，用于后续train</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">data_X = f[ref_X][:]</span><br><span class="line">data_y = f[ref_y][:]</span><br><span class="line">nUsers = f[<span class="string">&#x27;usr_data&#x27;</span>].shape[1]</span><br><span class="line"><span class="comment"># (4, 10240, 30),</span></span><br><span class="line">nRxAts, inPreambLen, nPackets = data_X.shape</span><br><span class="line"><span class="comment"># (4, 32, 234, 30)，其中nRxAts表示接受端天线数量，nTxAts表示发送端天线数量</span></span><br><span class="line">nRxAts, nTxAts, nSubCarr, nPackets = data_y.shape</span><br><span class="line">P = f[<span class="string">&#x27;P&#x27;</span>][:]  <span class="comment"># retrieve pilot sequences matrix</span></span><br><span class="line"></span><br><span class="line">trainX_temp = np.zeros((nPackets*nTxAts*nRxAts, <span class="number">2</span>), dtype=int) # for every datapoint, this will contain every unique LTF relative [hash, iTx]</span><br><span class="line">trainy_real_temp = np.zeros((nPackets*nRxAts*nTxAts,nSubCarr))</span><br><span class="line">trainy_imag_temp = np.zeros((nPackets*nRxAts*nTxAts,nSubCarr))</span><br><span class="line"></span><br><span class="line"><span class="comment"># d是real和imag</span></span><br><span class="line"><span class="keyword">for</span> i, sampleIx <span class="keyword">in</span> enumerate(list_IDs_temp):</span><br><span class="line">    <span class="comment"># Store sample</span></span><br><span class="line">    Xsig[i] = self.dataset[<span class="string">&#x27;LTF&#x27;</span>][self.dataset[<span class="string">&#x27;X&#x27;</span>][sampleIx, 0]][self.d][</span><br><span class="line">                              0:int(self.prm[<span class="string">&#x27;lenLTF&#x27;</span>] / self.fraction)][:, np.newaxis]</span><br><span class="line">    Xp[i] = self.dataset[<span class="string">&#x27;P&#x27;</span>][:, self.dataset[<span class="string">&#x27;X&#x27;</span>][sampleIx, 1]]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Store class</span></span><br><span class="line">    y[i] = self.dataset[<span class="string">&#x27;y&#x27;</span>][self.d][sampleIx, :]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="Training"><a href="#Training" class="headerlink" title="Training"></a>Training</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">earlystop = EarlyStopping(patience=10, restore_best_weights=True)</span><br><span class="line">reduce_lr = ReduceLROnPlateau(<span class="built_in">factor</span>=0.1, patience=20)</span><br><span class="line">callbacks = [earlystop, reduce_lr]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> args.method == <span class="string">&#x27;default_SNR&#x27;</span>:</span><br><span class="line">    applyGaussNoise = changeNoisePower(avg_sigPow, ...)</span><br><span class="line">    callbacks.append(applyGaussNoise)</span><br><span class="line"></span><br><span class="line">CSI_predictor.fit(</span><br><span class="line">    x=train_generator,</span><br><span class="line">    validation_data=valid_generator,</span><br><span class="line">    epochs=args.epochs,</span><br><span class="line">    callbacks=callbacks</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="Evaluation-Metrics"><a href="#Evaluation-Metrics" class="headerlink" title="Evaluation Metrics"></a>Evaluation Metrics</h4><h5 id="信道估计来源（estSource）"><a href="#信道估计来源（estSource）" class="headerlink" title="信道估计来源（estSource）"></a>信道估计来源（estSource）</h5><ul>
<li><code>estSource = 3</code>：使用 DNN 进行信道估计. </li>
<li><code>estSource = 4</code>：使用完美 CSI（理想信道）<br>来自低噪声情况下的信道估计</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">rxPreAmp_lowNoise = phased.ReceiverPreamp( ...</span><br><span class="line">            <span class="string">&#x27;Gain&#x27;</span>,gain_dB, ...    % account <span class="keyword">for</span> path loss</span><br><span class="line">            <span class="string">&#x27;NoiseMethod&#x27;</span>, <span class="string">&#x27;Noise power&#x27;</span>, ...</span><br><span class="line">            <span class="string">&#x27;NoisePower&#x27;</span>, db2pow(-100));        </span><br><span class="line">        </span><br><span class="line">rxPreSigAmp_real = rxPreAmp_lowNoise(rxPreSig&#123;uIdx&#125;); </span><br><span class="line">%   scale power <span class="keyword">for</span> used sub-carriers</span><br><span class="line">rxPreSigAmp_real = rxPreSigAmp_real * (sqrt(prm.FFTLength - ...</span><br><span class="line">    length(prm.NullCarrierIndices))/prm.FFTLength);</span><br><span class="line">        </span><br><span class="line">inputRXSig_real = rxPreSigAmp_real(chanDelay(uIdx)+1: ...</span><br><span class="line">                 end-(prm.numPadZeros-chanDelay(uIdx)),:);</span><br><span class="line">% OFDM demodulation</span><br><span class="line">rxOFDM_real = ofdmdemod(inputRXSig_real,prm.FFTLength, ...</span><br><span class="line">            prm.CyclicPrefixLength,prm.CyclicPrefixLength, ...</span><br><span class="line">            prm.NullCarrierIndices,prm.PilotCarrierIndices);</span><br><span class="line"></span><br><span class="line">% Channel estimation from preamble</span><br><span class="line">%       numCarr, numTx, numRx</span><br><span class="line">% Using classic (LS) method</span><br><span class="line">[hDp_real&#123;uIdx&#125;,~,~,~] = helperMIMOChannelEstimate(rxOFDM_real(:,1:numTx,:),prm,1,h,snr_dB_CS,<span class="literal">false</span>);     </span><br></pre></td></tr></table></figure>

<h5 id="NMSE计算"><a href="#NMSE计算" class="headerlink" title="NMSE计算"></a>NMSE计算</h5><p>使用 <code>NMSE_subk</code> 函数计算每个子载波、每对天线的归一化均方误差，并取平均：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> [out] = NMSE_subk(real, pred)</span><br><span class="line">    diff = real - pred;</span><br><span class="line">    tx = size(real,2);</span><br><span class="line">    rx = size(real,3);</span><br><span class="line">    subK_nmse = zeros(tx,rx);</span><br><span class="line">    <span class="keyword">for</span> t=1:tx</span><br><span class="line">        <span class="keyword">for</span> r=1:rx</span><br><span class="line">            subK_nmse(t,r) = norm(squeeze(diff(:,t,r)))^2 / norm(squeeze(real(:,t,r)))^2;</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">    out = mean(subK_nmse, <span class="string">&#x27;all&#x27;</span>);</span><br><span class="line">end</span><br></pre></td></tr></table></figure>


<h5 id="BER-Bit-Error-Rate"><a href="#BER-Bit-Error-Rate" class="headerlink" title="BER(Bit Error Rate)"></a>BER(Bit Error Rate)</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> estSource=1:4   % 1 = LS est.; 2 = MMSE est.; 3 = DNN est.; 4 = perfect est.</span><br><span class="line">        <span class="keyword">if</span> estSource == 3</span><br><span class="line">            hDp&#123;1&#125; = hDpDNN&#123;1&#125;; % only substitute <span class="keyword">for</span> user ID=1</span><br><span class="line">        elseif estSource == 2</span><br><span class="line">            hDp = hDp_mmse;</span><br><span class="line">        elseif estSource == 4</span><br><span class="line">            hDp = hDp_real;</span><br><span class="line">        end</span><br><span class="line">        [Fbb,Frf] = omphybweights(hDp&#123;1&#125;, numSTS, numSTS, AtExp);</span><br><span class="line">        mFrf = permute(mean(Frf,1), [2 3 1]);</span><br><span class="line">        preData(carrIdx,symIdx,:) = squeeze(gridData(carrIdx,symIdx,:)).<span class="string">&#x27; * normQ;</span></span><br><span class="line"><span class="string">        txSig = txSigSTS * mFrf;</span></span><br><span class="line"><span class="string">        ...</span></span><br><span class="line"><span class="string">        % Compute and display bit error rate</span></span><br><span class="line"><span class="string">        ber = comm.ErrorRate;</span></span><br><span class="line"><span class="string">        measures = ber(txDataBits&#123;uIdx&#125;,rxBits);        </span></span><br></pre></td></tr></table></figure>
<h5 id="EVM-Error-Vector-Magnitude"><a href="#EVM-Error-Vector-Magnitude" class="headerlink" title="EVM(Error Vector Magnitude)"></a>EVM(Error Vector Magnitude)</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">evm = comm.EVM(<span class="string">&#x27;Normalization&#x27;</span>,<span class="string">&#x27;Average constellation power&#x27;</span>, ...</span><br><span class="line">                <span class="string">&#x27;ReferenceSignalSource&#x27;</span>,<span class="string">&#x27;Estimated from reference constellation&#x27;</span>, ...</span><br><span class="line">                <span class="string">&#x27;ReferenceConstellation&#x27;</span>, ...</span><br><span class="line">                qammod((<span class="number">0</span>:prm.modMode-<span class="number">1</span>)&#x27;,prm.modMode,&#x27;UnitAveragePower&#x27;,<span class="number">1</span>));</span><br><span class="line">rmsEVM = evm(rxSymbs);</span><br><span class="line">            </span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://hechenyi.github.io/2025/04/28/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E6%B1%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/04/28/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E6%B1%A0/" class="post-title-link" itemprop="url">C语言实现线程池</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-04-28 17:34:56" itemprop="dateCreated datePublished" datetime="2025-04-28T17:34:56+08:00">2025-04-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-27 06:21:25" itemprop="dateModified" datetime="2025-05-27T06:21:25+08:00">2025-05-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      
          <h2 id="Basic-Concept"><a href="#Basic-Concept" class="headerlink" title="Basic Concept"></a>Basic Concept</h2><p>在高并发程序中，频繁创建和销毁线程会造成较大的资源消耗和系统开销。线程池（Thread Pool）是一种常用的并发编程技术，通过维护一个线程集合来处理任务，避免频繁创建和销毁线程，提高系统性能<br>线程池通常具备以下功能：</p>
<ul>
<li>支持动态添加任务</li>
<li>线程复用，减少线程创建销毁的开销</li>
<li>任务队列支持FIFO机制</li>
<li>线程池的销毁与资源回收</li>
</ul>
<h2 id="Producer-Consumer-Model"><a href="#Producer-Consumer-Model" class="headerlink" title="Producer-Consumer Model"></a>Producer-Consumer Model</h2><p>以下元素和结构几乎出现在所有经典线程池实现中:</p>
<table>
<thead>
<tr>
<th>组件</th>
<th>功能说明</th>
<th>是否为标准做法</th>
</tr>
</thead>
<tbody><tr>
<td><strong>线程数组</strong></td>
<td>预先创建固定数量的线程，用于处理任务</td>
<td>✅ 是</td>
</tr>
<tr>
<td><strong>任务队列</strong></td>
<td>存放尚未处理的任务，按顺序排队</td>
<td>✅ 是</td>
</tr>
<tr>
<td><strong>互斥锁（mutex）</strong></td>
<td>用于保护任务队列的访问，防止多个线程竞争资源</td>
<td>✅ 是</td>
</tr>
<tr>
<td><strong>条件变量（cond）</strong></td>
<td>当任务队列为空时阻塞线程，有新任务时唤醒工作线程</td>
<td>✅ 是</td>
</tr>
<tr>
<td><strong>无限循环的 <code>worker_thread</code></strong></td>
<td>每个线程不断尝试从任务队列中取任务并执行</td>
<td>✅ 是</td>
</tr>
<tr>
<td><strong>stop 标志</strong></td>
<td>控制线程池的销毁流程，优雅地通知线程退出</td>
<td>✅ 是</td>
</tr>
<tr>
<td><strong>任务结构包含 function + arg</strong></td>
<td>支持传入任意函数和参数，使线程池任务更通用</td>
<td>✅ 是</td>
</tr>
</tbody></table>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>这涉及同步的概念，需要满足同步与互斥，因此需要使用互斥锁（pthread_mutex_t）来保证任务队列操作的线程安全，以及需要条件变量（pthread_cond_t）用于通知线程处理任务<br>下面代码展示了 初始化线程池 -&gt; 添加任务到线程池 -&gt; 把任务从线程池中取出来，执行task里的function，并以此构建工作线程。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;pthread.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;unistd.h&gt;</span></span><br><span class="line">typedef struct task&#123;</span><br><span class="line">    void (*<span class="keyword">function</span>) (void *);</span><br><span class="line">    void *arg;</span><br><span class="line">    struct task *next;</span><br><span class="line">&#125; task_t;</span><br><span class="line">typedef struct&#123;</span><br><span class="line">    /// 互斥锁</span><br><span class="line">    pthread_mutex_t lock;</span><br><span class="line">    /// 条件变量</span><br><span class="line">    pthread_cond_t cond;</span><br><span class="line">    /// 线程数组</span><br><span class="line">    pthread_t *threads;</span><br><span class="line">    /// 任务队列</span><br><span class="line">    task_t *task_queue;</span><br><span class="line">    int thread_count;</span><br><span class="line">    int stop;</span><br><span class="line">&#125; thread_pool_t;</span><br><span class="line"></span><br><span class="line">// 线程池实例</span><br><span class="line">thread_pool_t pool;</span><br><span class="line"></span><br><span class="line">// 线程执行的任务函数,这里具体来说是从pool里的任务队列中把任务一个一个的取出来，然后再执行任务里的<span class="keyword">function</span>，把然后放到当前work_thread执行。</span><br><span class="line">void *worker_thread(void *arg)&#123;</span><br><span class="line">    <span class="keyword">while</span>(1)&#123;</span><br><span class="line">        pthread_mutex_lock(&amp;pool.lock);</span><br><span class="line">        // 等待任务</span><br><span class="line">        <span class="keyword">while</span>(pool.task_queue == NULL &amp;&amp; !pool.stop)&#123;</span><br><span class="line">            pthread_cond_wait(&amp;pool.cond, &amp;pool.lock);</span><br><span class="line">        &#125;</span><br><span class="line">        // 检查是否需要终止线程</span><br><span class="line">        <span class="keyword">if</span>(pool.stop)&#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;pool.lock);</span><br><span class="line">            pthread_exit(NULL);</span><br><span class="line">        &#125;</span><br><span class="line">        // 取出任务</span><br><span class="line">        task_t *task = pool.task_queue;</span><br><span class="line">        <span class="keyword">if</span>(task)&#123;</span><br><span class="line">            pool.task_queue = task-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_mutex_unlock(&amp;pool.lock);</span><br><span class="line">        <span class="keyword">if</span>(task)&#123;</span><br><span class="line">            task-&gt;<span class="keyword">function</span>(task-&gt;arg);</span><br><span class="line">            free(task);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void thread_pool_init(int thread_count)&#123;</span><br><span class="line">    pool.thread_count = thread_count;</span><br><span class="line">    pool.stop = 0;</span><br><span class="line">    pool.task_queue = NULL;</span><br><span class="line">    pthread_mutex_init(&amp;pool.lock, NULL);</span><br><span class="line">    pthread_cond_init(&amp;pool.cond, NULL);</span><br><span class="line">    pool.threads = (pthread_t *) malloc(sizeof(pthread_t)*thread_count );</span><br><span class="line">    // 创建工作线程</span><br><span class="line">    <span class="keyword">for</span>(int i = 0; i &lt; thread_count; i++)&#123;</span><br><span class="line">        pthread_create(&amp;pool.threads[i], NULL, worker_thread, NULL);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 添加任务到线程池</span><br><span class="line">void thread_pool_add_task(void (*<span class="keyword">function</span>)(void *), void *arg)&#123;</span><br><span class="line">    task_t *new_task = (task_t *) malloc(sizeof(task_t));</span><br><span class="line">    new_task-&gt;<span class="keyword">function</span> = <span class="keyword">function</span>;</span><br><span class="line">    new_task-&gt;arg = arg;</span><br><span class="line">    new_task-&gt;next = NULL;</span><br><span class="line">    pthread_mutex_lock(&amp;pool.lock);</span><br><span class="line">    //添加到任务队列尾部</span><br><span class="line">    <span class="keyword">if</span>(pool.task_queue == NULL)&#123;</span><br><span class="line">        pool.task_queue = new_task;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        task_t *temp = pool.task_queue;</span><br><span class="line">        <span class="keyword">while</span>(temp-&gt;next)&#123;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        temp-&gt;next = new_task;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_cond_signal(&amp;pool.cond);</span><br><span class="line">    pthread_mutex_unlock(&amp;pool.lock);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">// 关闭线程池</span><br><span class="line">void <span class="function"><span class="title">thread_pool_destroy</span></span>()&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;pool.lock);</span><br><span class="line">    pool.stop = 1;</span><br><span class="line">    pthread_cond_broadcast(&amp;pool.cond);</span><br><span class="line">    pthread_mutex_unlock(&amp;pool.lock);</span><br><span class="line">    // 等待所有线程结束</span><br><span class="line">    <span class="keyword">for</span>(int i = 0; i &lt; pool.thread_count; i++)&#123;</span><br><span class="line">        pthread_join(pool.threads[i], NULL);</span><br><span class="line">    &#125;</span><br><span class="line">    free(pool.threads);</span><br><span class="line">    task_t *task;</span><br><span class="line">    <span class="keyword">while</span>(pool.task_queue)&#123;</span><br><span class="line">        task = pool.task_queue;</span><br><span class="line">        pool.task_queue = task-&gt;next;</span><br><span class="line">        free(task);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_destroy(&amp;pool.lock);</span><br><span class="line">    pthread_cond_destroy(&amp;pool.cond);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 测试任务</span><br><span class="line">void test_task(void *arg)&#123;</span><br><span class="line">    int num = *(int *) arg;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;线程 %ld 正在执行任务 %d\n&quot;</span>, pthread_self(),num);</span><br><span class="line">    <span class="built_in">sleep</span>(1);</span><br><span class="line">&#125;</span><br><span class="line">int <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">    //  创建四个线程</span><br><span class="line">    thread_pool_init(4);</span><br><span class="line">    <span class="keyword">for</span>(int i = 0; i &lt; 10; i++)&#123;</span><br><span class="line">        int *task_num = malloc(sizeof(int));</span><br><span class="line">        *task_num = i;</span><br><span class="line">        thread_pool_add_task(test_task, task_num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sleep</span>(5);</span><br><span class="line">    thread_pool_destroy;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://hechenyi.github.io/2025/04/27/FDD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/04/27/FDD/" class="post-title-link" itemprop="url">FDD</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-04-27 06:47:02" itemprop="dateCreated datePublished" datetime="2025-04-27T06:47:02+08:00">2025-04-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 06:48:46" itemprop="dateModified" datetime="2025-04-28T06:48:46+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/5G/" itemprop="url" rel="index"><span itemprop="name">5G</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      
          <h2 id="Basic-Concept"><a href="#Basic-Concept" class="headerlink" title="Basic Concept"></a>Basic Concept</h2><p>在FDD系统中，信道被分为上行链路（UL，uplink）和下行链路（DL，downlink），它们分别使用不同的频段进行通信。因此在FDD通信是同时进行上行和下行的。<br>在FDD系统和TDD系统中有多种调度算法：</p>
<ul>
<li>RR（Round Robin） 这种调度算法主要关注公平性，即尽可能平等地分配资源给所有用户</li>
<li>PF（比例公平调度，Proportional Fair），这种算法试图在公平性和吞吐量之间找到一个折衷，它在考虑公平性的同时，优先选择信道质量好的用户。相比RR，它能在吞吐量和公平性之间达到较好的平衡。</li>
<li>Best CQI（最佳信道质量指示符调度） 这种调度算法优先选择信道质量好的用户，这能显著提高下行和上行的吞吐量，因为它充分利用了信道质量信息，但是牺牲了公平性。</li>
</ul>
<p>在NR FDD测试中需要构建RLC层，因为:</p>
<ul>
<li>需要模拟真实数据流的传输过程</li>
<li>RLC层决定了数据如何从上到下分发、管理和重传</li>
<li>真实的链路有丢包、重传、顺序乱序等问题要处理</li>
</ul>
<h3 id="RLC"><a href="#RLC" class="headerlink" title="RLC"></a>RLC</h3><p>RLC全称是Radio Link Control，用于无线链路控制，主要是保证数据传输的可靠性，其融合了OSI七层协议的数据链路层和传输层的功能和机制，包括滑动窗口、ARQ等等 </p>
<h4 id="SDU和PDU"><a href="#SDU和PDU" class="headerlink" title="SDU和PDU"></a>SDU和PDU</h4><p>在协议体系里，下层协议是为上层协议提供服务(service)的，因此凡是上层发过来的或者发往上层的数据都叫SDU(Service Data Unit)。而上层协议(Protocol)实体对数据进行处理后，通过下层协议提供的服务继续往后面发送，因此凡是发给下层或从下层收到的数据叫做PDU(Protocol Data Unit)<br>例如Network Layer的SDU可以理解为Packet，MAC的PDU可以理解为Frame</p>
<h4 id="三种传输模型"><a href="#三种传输模型" class="headerlink" title="三种传输模型"></a>三种传输模型</h4><ul>
<li>TM - Transparent Mode<br>发射端不对RLC SDU做分段操作，也不添加RLC Header，只是缓存数据，接收端同理，收到数据后直接发给上层。</li>
<li>UM - Unacknowledged Mode<br>无响应模式，类似UDP，发射端可以对数据进行分段处理，但不需要接收端反馈接收状态</li>
<li>AM - Acknowledged Mode<br>响应模式，接收端通过RLC status report反馈包接收状态，发射端根据status report决定是否重传数据</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openExample(<span class="string">&#x27;5g/NRFDDSchedulingPerformanceEvaluationExample&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>这个例子展示了RR scheduler. The scheduler allocates resources based on pending retransmissions, buffer status, and channel quality for the UE nodes.<br><img src="/images/FDDScheduler.png"></p>
<h2 id="分析代码"><a href="#分析代码" class="headerlink" title="分析代码"></a>分析代码</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">networkSimulator = wirelessNetworkSimulator.init; ///Create a wireless network simulator</span><br></pre></td></tr></table></figure>
<p>gNB &#x3D; nrGNB(Position &#x3D; [0 0 30], DuplexMode &#x3D; “FDD”, CarrierFrequency &#x3D; 2.6e9, ChannelBandwidth &#x3D; 30e6, SubcarrierSpacing &#x3D; 15e3, ReceiveGain &#x3D; 11);</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">configureScheduler(gNB,Scheduler=<span class="string">&quot;RoundRobin&quot;</span>,ResourceAllocationType=0);</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uePositions = [100 0 3; 250 0 3; 700 0 3; 750 0 3];</span><br><span class="line">ueNames = <span class="string">&quot;UE-&quot;</span> + (1:size(uePositions,1));</span><br><span class="line">UEs = nrUE(Name=ueNames,Position=uePositions,ReceiveGain=11);</span><br></pre></td></tr></table></figure>
<p>Set ue positions</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/// Set the AppConfig parameter.</span><br><span class="line">load(<span class="string">&quot;NRFDDAppConfig.mat&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>输出的AppConfig结构体，里面都是有关应用层流量配置和RLC配置（RNTI， LogicalChannelID）</p>
<ul>
<li>DataRate</li>
<li>PacketSize</li>
<li>HostDevice</li>
<li>RNTI(Radio network temporary identifier of a UE node.)</li>
<li>LogicalChannelID</li>
<li>BearerType</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">load(<span class="string">&quot;NRFDDRLCChannelConfig.mat&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>这是用于配置RLC,以下参数是有关RLC配置<br>注意RNTI用于唯一标识UE，它是临时的标识符，用于上下文中的调度和通信。<br>LogicalChannelID用于标识UE上的具体逻辑信道，它区分不同类型的数据流或信号。<br>RNTI和LogicalChannelID的结合可以唯一标识某个UE上的特定数据流，确保数据的正常调度和传输。</p>
<ul>
<li>RNTI</li>
<li>LogicalChannelID</li>
<li>LogicalChannelGroup</li>
<li>RLCEntityType</li>
<li>Priority</li>
<li>SNFieldLength</li>
<li>BufferSize</li>
<li>PollPDU</li>
<li>PollByte</li>
<li>PollRetransmitTimer</li>
<li>MaxRetxThreshold</li>
<li>ReassemblyTimer</li>
<li>StatusProhibitTimer</li>
<li>PrioritizedBitRate</li>
<li>BucketSizeDuration<br>具体可参考matlab 5g tool中的nrRLCBearerConfig结构体</li>
</ul>
<p>在配置每个ue的RLC后，使用connectionUE函数将ue和gnb进行连接</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connectUE(gNB,UEs&#123;ueIdx&#125;, BSRPeriodicity=5, RLCBearerConfig=rlcBearers&#123;ueIdx&#125;);</span><br></pre></td></tr></table></figure>
<p>之后set the periodic DL and UL application traffic pattern for UEs.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app = networkTrafficOnOff(PacketSize=2000, GeneratePacket=<span class="literal">true</span>,OnTime=numFrameSimulation/100,OffTime=0,DataRate=AppConfig.DataRate(appIdx));</span><br><span class="line"><span class="keyword">if</span> AppConfig.HostDevice(appIdx) == 0</span><br><span class="line">% Add traffic pattern that generates traffic on downlink</span><br><span class="line">addTrafficSource(gNB, app, DestionationNode=UEs(AppConfig.RNTI(appIdx)), LogicalChannelID=AppConfig.LogicalChannelID(appIdx))</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">% Add traffic pattern that generates traffic on uplink</span><br><span class="line">addTrafficSource(UEs(AppConfig.RNTI(appIdx)),app,LogicalChannelID=AppConfig.LogicalChannelID(appIdx))</span><br></pre></td></tr></table></figure>

<p>Add the gNB and UE nodes to the network simulator</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">addNodes(networkSimulator,gNB)</span><br><span class="line">addNodes(networkSimulator,UEs)</span><br></pre></td></tr></table></figure>

<p>Use 3GPP TR 38.901 channel model for all links, take a free space path loss model as example</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">channelModel = <span class="string">&quot;3GPP TR 38.901&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> strcmp(channelModel,<span class="string">&quot;3GPP TR 38.901&quot;</span>)</span><br><span class="line">    % Define scenario boundaries</span><br><span class="line">    pos = reshape([gNB.Position UEs.Position],3,[]);</span><br><span class="line">    minX = min(pos(1,:));          % x-coordinate of the left edge of the scenario <span class="keyword">in</span> meters</span><br><span class="line">    minY = min(pos(2,:));          % y-coordinate of the bottom edge of the scenario <span class="keyword">in</span> meters</span><br><span class="line">    width = max(pos(1,:)) - minX;  % Width (right edge of the 2D scenario) <span class="keyword">in</span> meters, given as maxX - minX</span><br><span class="line">    height = max(pos(2,:)) - minY; % Height (top edge of the 2D scenario) <span class="keyword">in</span> meters, given as maxY - minY</span><br><span class="line"></span><br><span class="line">    % Create the channel model</span><br><span class="line">    channel = h38901Channel(Scenario=<span class="string">&quot;UMa&quot;</span>,ScenarioExtents=[minX minY width height]);</span><br><span class="line">    % Add the channel model to the simulator</span><br><span class="line">    addChannelModel(networkSimulator,@channel.channelFunction);</span><br><span class="line">    connectNodes(channel,networkSimulator);</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>Run the simulation for the specified numFrameSimulation frames</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">simulationTime = numFrameSimulation*1e-2;</span><br><span class="line">run(networkSimulator, simulationTime);</span><br><span class="line">% Read per-node statistics</span><br><span class="line">gNBStats = statistics(gNB, <span class="string">&quot;all&quot;</span>);</span><br><span class="line">ueStats = statistics(UEs);</span><br></pre></td></tr></table></figure>

<p>Show prefomrance like throughput and spectral efficiency(UL and DL)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">displayPerformanceIndicators(metricsVisualizer);</span><br></pre></td></tr></table></figure>

<p>输出的metricVisulaizer里面有MACTxBytes、MACRxBytes，可以用来计算throughput和data rate，需要注意的是MACTxBytes和MACRxBytes都有两列，分别对应的UL和DL，以MACTxBytes为例，UL一列对应的是ue端，而DL一列则对应的是gNB端，下面代码可以佐证</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">txBytes = gNBMACStats(rnti).TransmittedBytes + gNBMACStats(rnti).RetransmissionBytes;</span><br><span class="line">txRate(ueIdx, obj.DownlinkIdx) = (txBytes - obj.MACTxBytes(ueIdx, obj.DownlinkIdx))* 8 / (obj.MetricsStepDuration * 1000); % In Mbps</span><br><span class="line">bufferstatus(ueIdx, obj.DownlinkIdx) = bufferSize(rnti) ./ 1000; % In KB</span><br><span class="line">% Save the previous metrics</span><br><span class="line">obj.MACTxBytes(ueIdx, obj.DownlinkIdx) = txBytes;</span><br></pre></td></tr></table></figure>

<p>有点累，总之明天见</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://hechenyi.github.io/2025/04/24/%E9%9A%8F%E7%AC%94/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/04/24/%E9%9A%8F%E7%AC%94/" class="post-title-link" itemprop="url">随笔</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-04-24 22:32:31" itemprop="dateCreated datePublished" datetime="2025-04-24T22:32:31+08:00">2025-04-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-08-28 14:48:50" itemprop="dateModified" datetime="2025-08-28T14:48:50+08:00">2025-08-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      
          <p>It did not take evil to produce evil.</p>
<p>你要是没有碰到那个坏事，你就学不到对付那个坏事的本事，所以艰难困苦能使我们的事业成功</p>
<p>在危险环境中表示绝望的人，在黑暗中看不见光明的人，只是懦夫与机会主义者  </p>
<p>有利的条件和主动的恢复，产生于再坚持一下的努力之中  </p>
<p>泱泱华夏，一撇一捺皆是脊梁<br>神州大地，一丝一念皆是未来<br>浩浩九州，一文一墨均是骄阳</p>
<p>在坚冰还盖着北海的时候，我看到了怒放的梅花  </p>
<p>政治越改进，抗战越能坚持；抗战越坚持，政治就越能改进。抗战的经验已经证明，十个月的中国人民的进步抵得上过去多少年的进步。</p>
<p>A person with a similar soul is like gift.</p>
<p>读万卷书行万里路，胸中脱去尘埃。 </p>
<p>有一个喜欢的人真的太重要了，在你打算稀里糊涂过这普普通通一生的时候，会因为对方而再想要努力一下，在那么多疲惫不堪甚至抬不起头的日子里，会因为对方而觉得人生还有盼头。因为有念想，才有动力，对生活才会释放更多热情。总之岁月漫长，然而值得等待。  – 村上春树</p>
<p>爱情不是整天无所事事的黏在一起</p>
<p>人民民主专政的基础是工人阶级、农民阶级和城市小资产阶级的联盟，而主要是工人和农民的联盟，因为这两个阶级占了中国人口的百分之八十到九十。推翻帝国主义和国民党反动派，主要是这个两个阶级的力量。由新民主主义到社会主义，主要依靠这两个阶级的联盟。孙中山的“唤起民众”“扶助农工”的意思是说小资产阶级和民族资产阶级。</p>
<p>我们必须克服苦难，我们必须学会自己不懂的东西。我们必须向一切内行的人们（不管什么人）学经济工作。拜他们做老师，恭恭敬敬地学，老老实实地学。不懂就是不懂，不要装懂。</p>
<p>life always finds its own way out.</p>
<p>好像那时我们都在，当时的事都记了起来，时间真的像是长了脚的妖怪，跑的飞快。<br>往事只是冰冷冷的过往，只是因为人的到来而变的温暖。</p>
<p>我和你投缘，你和我同频，我们俩就这样在一起吧</p>
<p>始于颜值，敬于才华，合于性格，久于善良，终于人品<br>和漂亮的人在一起，会越来越美，和阳光的人在一起，心里就会很阳光，和快乐的人在一起，嘴角就常带微笑，和聪明的人在一起，做事就变机敏，和大方的人在一起，出事就不小气，和睿智的人在一起，遇事就不迷茫。<br>而你，漂亮阳光快乐聪明大方睿智，夫欲何求。</p>
<p>一个人真正值得炫耀的东西，是善良，是教养，是包容。是见过世面的涵养，向阳而生，努力向上，做一个温暖的人。 </p>
<p>本质是在失去后显现</p>
<p>享受阳光，保证休息，坚持锻炼，健康饮食，强大自信，真心的朋友</p>
<p>坚持原则的你，被说固执；推陈出新的你，被指激进。<br>改变世界的人，不需要掌声铺路；那些撼动时代的理想，往往先把自己活成火炬。<br>花不语，<br>跪着把理想捂热的人，站着看的世界更辽阔</p>
<p>If your feelings are still what they were last April, tell me so at once, my affections and wishes have not changed.</p>
<p>Dear Cecilia, the story can resume.  </p>
<p>Do not go gentle into that good night. Old age should burn and rave at close of day. Rage, rage against the dying light.</p>
<p>So do you want to take a leap of faith, or become an old man, filled with regret waiting to die alone?</p>
<p>分享欲是靠回应来延续的，热情也是</p>
<p>社会形态的转变需要时间，而在一个历史角度上很短篇幅的转变时间，落在一代人身上就是他们的一身</p>
<p>但我所说的中国革命高潮快要到来，决不是如有些人所谓“有到来之可能”那样完全没有行动意义的、可望而不可即的一种空的东西。它是站在海岸遥望海中已经看得见桅杆尖头了的一只航船，它是立于高山之巅远看东方已见光芒四射喷薄欲出的一轮朝日，它是躁动于母腹中的快要成熟了的一个婴儿。</p>
<p>天在将黑未黑时最美，爱在将爱未爱时最迷人</p>
<p>只有知道了书的结尾，才会明白书的开头。可正在阅读开头之时又怎知故事结尾</p>
<p>枯木会逢春</p>
<p>当牵牛花初开的时节，葬礼的号角就已吹响。但是太阳，它每时每刻都是夕阳也都是旭日。当它熄灭着走下山去收尽苍凉残照之际，正是它在另一面燃烧着爬上山巅布满烈烈朝晖之时。</p>
<p>时间可以吞噬一切，但它丝毫不能减少的是你伟大的思想，你的幽默，你的善良，还有你的勇气。</p>
<p>我们并不是生活在土地上，事实上我们生活在时间里。田野、街道、河流、房屋是我们置身度外时间之中的伙伴。时间将我们推移向前或向后，并改变这我们的模样</p>
<p>节省每一个铜板为着战争和革命事业，为着我们的经济建设，是我们的会计制度的原则。</p>
<p>尊重，是一种被教育出来的浪漫，穿上它是荣耀，铺下来是敬重，大学是文明的灯塔，也是人性的熔炉。在毕业典礼的人潮中回望，才会明白这方天地最珍贵的从不是文凭，而是他慷慨赠予每个闯入者的礼物。<br>永远对未知保持最谦卑的热望，这不仅是人类文明的保险柜，放着千年智慧的结晶，更是未来的孵化器，脚踏先辈脊梁，触碰更耀眼的光芒。</p>
<p>春华秋实，生命的意义就在于它的无意义，花海盛开的璀璨，燕子归来的安心，有闪光就会有坠落的必经之路，吟唱声声，像是一句句呼唤，呼唤遗落在远方的人的心。情绪的荒岛一定会生出灿烂的玫瑰，在温润有力又极具故事感的声音里，感受到了坚定存在的信念，在浩瀚星辰里看到平凡生活里的闪光。</p>
<p>如果你站在童年的位置，展望未来，你会说前途无量，但是你如果站在终点看生命的轨迹，你就只能看到一条命运之路。你不知道命运是什么，才知道什么是命运，所以很多人口中说的，看不到孩子的未来，其实是看到了未来，人生唯一的确定性，就是不确定。所以大胆的让孩子去做他想做的任何事情，任何美好的事情，活在当下，抓住一切的美好。</p>
<p>我站在今天设想过去又幻想未来，过去和未来在今天随意交叉，因而过去和未来都刮着现在的风。</p>
<p>时间是个怪物，最令人不解的迷，同时时间又是长了脚的妖怪，跑的飞快。</p>
<p>莫逆之交</p>
<p>我在感情上的愚钝就像是门窗紧闭的屋子，虽然爱情的脚步在屋前走过去又走过来，我也听到了，可是我觉得那是路过的脚步，那是走向别人的脚步。直到有一天，这个脚步停留在这里，然后门铃响了。</p>
<p>任何影响，只会让一个人变得越来越像他自己，而不会像别人，这就是阅读和学习爱给我们最好的一个体会。</p>
<p>环境不能影响一个人，而是揭示一个人</p>
<p>But poetry, beauty, romance, love … these are what we stay alive for.</p>
<p>生活的意义在于独立自我，教育的本质在于独立思考。从老师的角度来说先传道后有授业解惑，而从学生的角度出发行有余力则以学文，教育往往不必将学习直至首位，精神的建立，思想的塑造，才是真正的重要。</p>
<p>被动和逃避总是很容易让人错失那些美好，而只有懂得了真正的勇敢和真正的释怀，生者才可以更好地生，死亡才能不成为伤疤，而成为释怀的记忆。</p>
<p>并未在一起亦无从离弃<br>不用沦为伴侣别寻是惹非<br>就像蝴恋花后无凭无据<br>亲密维持十秒又随伴远飞</p>
<p>曾谈情到天亮</p>
<p>“I know of no better life purpose than to perish in attempting the great and the impossible…”  —  Nietzsche, 1873.</p>
<p>生命就像是一个疗伤的过程，我们受伤，痊愈，再受伤。每一次的痊愈好像都是为了迎接下一次的受伤。或许总要彻彻底底的绝望一次，才能重新再活一次。</p>
<p>大江歌罢掉头东，邃密群科济世穷。<br>面壁十年图破壁，难酬蹈海亦英雄。</p>
<p>无由见颜色，还自托微波</p>
<p>无论海角与天涯，大抵心安即是家</p>
<p>一个真正的强者，在面对着非常严峻的形势，面对着命运的折磨的时候，他们能够挽救自己，他们有坚强的神经，钢铁一般的意志。</p>
<p>归梦碧纱窗，说与人人道</p>
<p>秀色空绝世，馨香为谁传</p>
<p>This is the dream! It is conflict and it is compromise, and it is very, very exciting!</p>
<p>“余致力国民革命凡四十年，其目的在求中国之自由平等。积四十年之经验，深知欲达到此目的，必须唤起民众及联合世界上以平等待我之民族共同奋斗” – 孙中山</p>
<p>自主的，而非奴隶的。<br>进步的，而非保守的<br>进取的，而非退隐的<br>世界的，而非锁国的<br>实利的，而非虚文的<br>科学的，而非想象的<br>健壮的，而非体弱的</p>
<p>那个为中华之崛起而读书，全民讨论中国往何处去的历史是<strong>真实存在</strong>的，甚至很难相信，在那苦难的年代，认真竟是被大家所推崇的，理性的争论竟然是可以实现的。在这样的国土上，真的有这样一群人，一种生活方式，他们能为了国家付出，为了理想奋斗，而不仅仅只是关注自己基金的涨跌，脸上痘痘的多少，又或者新发的朋友圈有多少人点赞。总之，理想可以以真实的形式存在。</p>
<p>醒时同交欢，醉后各分离</p>
<p>理性认识依赖于感性认识，理性的东西所以靠得住，正是由于它来源于感性，否则理性的东西就成了无源之水，无木之本，而只是主观自生的靠不住的东西了。此外，也，认识有待于深化就是说认识不能只停顿在低级的感性阶段，否则就成了“经验论”的错误，因而不能通观客观过程的全体，也称为庸俗的事务主义家。理性认识之后需行动起来，在懂得了客观世界的规律性后需要去解释世界，也就是拿了这种对于客观规律性的认识去能动地改造世界，也可称之为改造世界的实践过程。总的来说，通过实践而发现真理，又通过实践而证实真理和发展真理。从感性认识而能动地发展到理性认识，又从理性认识而能动地指导革命实践，改造主观世界和客观世界。这就是辩证唯物论的知行统一观。</p>
<p>密切联系人民群众，洞悉社会弊病的人，然后将基于此形成的理性认识，并投入改造世界的实践过程的人，可称为先生。而大多是的人只了解少数精英阶层，而忽视底层的大多数。</p>
<p>中国人的性格和中国文明的三大特征，正是深沉，博大和淳朴，此外还有灵敏<br>—— 辜鸿铭《中国人的精神》</p>
<p>真正的平等，意味着一视同仁，门户开放，有教无类，或像伟大的拿破仑所表述的人尽其才，而不是将笨蛋与非笨蛋的头脑弄平，使国家中最好之人与最差之人一样差的绝对平等；真正的自由，并不意味着可以随心所欲，而是可以自由地做正确的事情，即中国经书中所谓率性之谓道。真正的民主，是指敞开的大门，没有出身、地位和种族之别，而不是指没有君、王权，更不是指庶民议政。大多数永远是不好的，他们不具备参政议政的能力。近代西方由大多数人来参与和支配政治的观念为群氓崇拜，它是非理性民主政治的来源，是欧美近来所有社会、政治和世界无政府状态的根源，也是导致欧洲大战的非直接原因。</p>
<p>不觉碧山暮，秋云暗几重</p>
<p>你终会明白前途比爱情重要，你还会明白爱情比前途更难得，但最后你会明白，对的人，会站在你的前途里。</p>
<p>不必听自暴自弃者流的话，只是向上走。不必等待炬火，此后如竟没有炬火，我便是唯一的光</p>
<p>犹记碧桃影里，誓三生。</p>
<p>千年史册耻无名，一片丹心报天子。</p>
<p>楚虽三户能亡秦，岂有堂堂中国空无人！</p>
<p>“我也明知白驹过隙，逝者如斯，未来可能讲更有意思的话，著更其完美的文，做更其壮丽的事业，但今天只是今天，未来也只是今天的未来。”</p>
<p>一点浩然气，千里快哉风。</p>
<p>过去都是假的，回忆是一条没有归途的路。过去的一切春天都不复存在，纵然最狂热、最坚定的爱情，归根结底不过是一种转瞬即逝的现实</p>
<p>大学ending，其实在ending前也时常会思考有什么遗憾的事情，我感觉大学四年还是很完美的，有在为成为更好的自己不断努力，也认识到了很多很好的朋友。以赴德为界，在华理认识到的班上的同学、隔壁班的德环同学还有学弟学妹们，后面在德国认识到的教会朋友还有德国朋友。我喜欢跟优秀的人交往，所幸的是大学四年我认识到的人都很优秀，也都很可爱。<br>那么真正遗憾的是什么，是因为水课导致均分0.04的分差与国奖失之交臂，还是六进五评选DAAD奖学金我却成为了那个一。感觉都不是，真正的遗憾是，苦于学生思维太久了，大一大二只知学习课本知识，沿用初高中的how to study而从未思考过why to stusy，这也导致了科研上手的太晚了，也做的不温不火，不过还是找到并确定了方向。当然这也是遗憾之一，还有其实性格上虽然改变了不少，我变得更加主动更加开朗了，也做到了基本上不发火不说脏话。但我知道这还远远不够，我还需要更加阳光积极，少一些焦躁。<br>无论如何，我很庆幸、很感激自己还是曾经预想的模样。没有哪一天是在浑浑噩噩中度过的，在思考和困惑中努力成长。</p>
<p>相逢一醉是前缘，风雨散、飘然何处  </p>
<p>求田问舍，怕应羞见，刘郎才气。可惜流年，忧愁风雨，树犹如此。  </p>
<p>因笑王谢诸人，登高怀远，也学英雄涕</p>
<p>悟已往之不谏，知来者之可追。</p>
<p>二十余年如一梦，此身虽在堪惊</p>
<p>一点浩然气，千里快哉风</p>
<p>古今如梦，何曾梦觉，但有旧欢新怨</p>
<p>可惜一溪风月，莫教踏碎琼瑶</p>
<p>你就是我的处境，我想逃离这个处境，已经跑到了“对跖点”的时候，我已发现无路可退。因为多迈一步，我就离我的处境有多了一步。但是如果走心的话，我们是最近的，不走心，可能就是最远的。</p>
<p>一个人能力有大小，但只要有这点精神（毫无自私自利之心的精神），就是一个高尚的人，一个纯粹的人，一个有道德的人，一个脱离了低级趣味的人，一个有益于人民的人。</p>
<p>做官之道，其实就三句话：和光同尘，雨露均沾，花花轿子众人抬。一人吃独食，是吃不长久的。</p>
<p>就算失败，我也想知道，自己倒在距离终点多远的地方。</p>
<p>给历史以一定的科学的地位，是尊重历史的辩证法的发展，而不是颂古非今，不是赞扬任何封建的毒素。对于人民群众和青年学生，主要地不是要引导他们向后看，而是要引导他们向前看。</p>
<p>你像是海鸥，强健，难以约束，喜欢狂风暴雨，远远飞向大海，自得其乐。</p>
<p>I am not throwing away my shot.</p>
<p>Raise a glass to the four of us. Tomorrow, there will be more of us.</p>
<p>教敷营，雨花台，挹江门，中山门，中华门</p>
<p>what is next? Shall we go next? How to go next?</p>
<p>须知少日拏云志，曾许人间第一流</p>
<p>不同时期中的青年有不同的使命。新民主主义革命时期，青春是慢慢长征路上那一声坚定的“跟着走”，走向柳暗花明的胜利之路；社会主义革命和建设时期，青春是一穷二白下的艰苦奋斗，向科学进军，向困难进军，向荒原进军；改革开放和社会主义现代化建设新时期，青春是勇立潮头，作改革闯将，开风气之先。而经济形势、就业形势欠佳的今天，我们青年又该何去何从，实质上奋斗永远是底色，昭昭前世，激励后人，勿负时代，勿负人民。</p>
<p>不必形色匆匆，不必光芒万丈，不必成为别人，只需做自己</p>
<p>君子疾夫舍曰欲之而必为之辞</p>
<p>我们读所有的书，最终的目的都是读到自己。让焦虑的心平息下来，突然有种豁然开朗的安全感，你会发现你百思不得其解的困惑，千百年来被无数的人思考过，而答案也就书中。</p>
<p>大江歌罢掉头东，邃密群科济世穷。<br>面壁十年图破壁，难酬蹈海亦英雄</p>
<p>青年如初春，如朝日，如百卉之萌动，如利刃之新发于石刑，人生之最可贵之时期也 – 陈独秀</p>
<p>绘事后素</p>
<p>注重外在文饰的同时，莫忘追求其本质，如西西弗斯一般，在虚无中扼杀虚无，在绝望中超越绝望，在不断的滚石途中磨砺自己的斗志，这才是真正的质。</p>
<p>岁月悠悠，衰微只及肌肤。热忱抛却，颓废必致灵魂。</p>
<p>不言而喻之中，一切自有深意</p>
<p>路虽远行则将至，事虽难做则必成</p>
<p>一个人时不辜负自己，玩的时候不辜负风景，爱的时候不辜负人</p>
<p>在自己身上克服这个时代 – 尼采</p>
<p>对未来最大的馈赠，就是将一切献给今天</p>
<p>内图个性之发展，外图贡献于其群</p>
<p>青春易逝，但成长是永恒的过程，真正有少年心性的人，是不停革新自我的人。</p>
<p>何须浅碧深红色，自是花中第一流。</p>
<p>每个人都是孤独地出生，在这世间恍惚几十年并不漫长的日子转眼就远去了，然后再孤独地死去。生命注定是个悲剧，因为我们从没有融入世界，世界永远是身外之物。如果有幸，能在茫茫人海寻得一个身体与灵魂都与自己万分契合的人，与之存在一种可以称之为爱情的联系，然后一起承受生命中不可逃离不可消除的深沉的宿命的孤独。可是这般的幸运艰深难得。有的已失去了爱的能力，有的爱得深沉却无法安放，有的死在这爱里。在所有的爱里，孤独有增无减。生命只是一场幻梦。</p>
<p>我们趋行在人生这个亘古的旅途，在坎坷中奔跑，在挫折里涅盘，忧愁缠满全身，痛苦飘洒一地。我们累，却无从止歇；我们苦，却无法回避。</p>
<p>迷茫的时候，充满活力也是浪费时间</p>
<p>民国时期的四大家族（蒋宋孔陈），既掌握政权和土地，又勾结外国资本，典型地表现为<strong>封建-买办的结合体</strong>。买办属于资产阶级的一部分，但他们并不独立发展资本，而是依附外国资本。</p>
<p>封建地主包括有大地主（地方豪绅、士绅），中小地主，官僚地主</p>
<p>因为当时马孔多百业待兴，时间不够。人们那么勤奋地工作，在短时间内就把一切都做完了，现在早晨三点就双臂交叉地坐着，计算自鸣钟的华尔兹舞曲有多少段曲调。想睡的人–井非由于疲乏，而是渴望做梦–采取各种办法把自己弄得精疲力尽，他们聚在一起，不住地絮絮叨叨，一连几小时把同样的奇闻说了又说，大讲特讲白色阉(又鸟)的故事。一直把故事搞得复杂到了极点。这是一种没完没了的玩耍–讲故事的人问其余的人。</p>
<p>一个孤立于现实、脱离社会的梦想者，注定被时间与孤独吞没</p>
<p>每个人都有一个觉醒期，但觉醒的早晚决定个人的命运</p>
<p>无论精神多么独立的人，感情却总是在寻找一种依附，寻找一种归附</p>
<p>君子博学于文，约之以礼，亦可以弗畔矣夫</p>
<p>科研评价指标的衍生问题。对于做通信来说，重在推公式的优化类文章，无论是在文章的生产速度上来说还是评审时的认可度来说，都是绝对优于脚踏实地做无线系统实验的文章。A博千辛万苦搭建了一个SDR系统，正准备在上面优化一些算法，然后发现无线复杂无比，哪哪下手都不容易，系统在跑的时候还动不动崩溃了(没错我说的就是OAI)。等好不容易在上面实现了创新，写成了paper，投稿还可能面临创新点不足(公式不够多)的风险，这个时候已经2-3年过去了。然后B博上来就是一堆优化公式，花了一年多时间小试身手，一区论文到手，接下来几年有了第一篇的经验，稳定产出。4年下来从评价指标来说，B博远远优秀与A博。面临科研和考核压力的博士和青年教师，会选择哪一条路显而易见。</p>
<p>以淡字交友，以聋字止谤；以刻字责己，以弱字御悔恨。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://hechenyi.github.io/2025/04/24/MATLAB%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/04/24/MATLAB%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/" class="post-title-link" itemprop="url">MATLAB基础语法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-04-24 14:50:46" itemprop="dateCreated datePublished" datetime="2025-04-24T14:50:46+08:00">2025-04-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-08-05 20:15:57" itemprop="dateModified" datetime="2025-08-05T20:15:57+08:00">2025-08-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MATLAB/" itemprop="url" rel="index"><span itemprop="name">MATLAB</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      
          <h2 id="向量处理"><a href="#向量处理" class="headerlink" title="向量处理"></a>向量处理</h2><p>a &#x3D; [1:3:100]<br>其中a是初始值，b是步长，c是终点值<br>返回结果是[1,4,7,…,100]<br>b(a) &#x3D; []<br>把向量b中的a对应索引给删掉</p>
<h2 id="列向量和横向量"><a href="#列向量和横向量" class="headerlink" title="列向量和横向量"></a>列向量和横向量</h2><p>列向量使用;<br>a &#x3D; [1;2;3]<br>b &#x3D; [4;5;6]<br>c &#x3D; [a;b]<br>其中c将两个列向量进行拼接<br>横向量使用逗号，其他同理<br>如果想使用a&#x3D;(1:100)类似语法构建列向量，可以先构建横向量，例如a&#x3D;(1:100),然后再使用(:)进行转换a&#x3D;a(:)</p>
<h2 id="table"><a href="#table" class="headerlink" title="table"></a>table</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">% 构建table</span><br><span class="line">RNTI = [1;2;3];</span><br><span class="line">LogicalChannelID = [3;4;5];</span><br><span class="line">RLCEntityType = [<span class="string">&quot;AM&quot;</span>; <span class="string">&quot;AM&quot;</span>; <span class="string">&quot;UM&quot;</span>];</span><br><span class="line">RLCChannelConfig = table(</span><br><span class="line">    RNTI, LogicalChannelID,LogicalChannelGroup,RLCEntityType,...</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line">% 查询表的行数</span><br><span class="line">nRows = size(RLCChannelConfig, 1);</span><br><span class="line">% 查询表的列数</span><br><span class="line">nCols = size(RLCChannelConfig, 2);</span><br><span class="line">% 把table保存成.mat文件</span><br><span class="line">save(<span class="string">&#x27;RLCChannelConfig.mat&#x27;</span>, <span class="string">&#x27;RLCChannelConfig&#x27;</span>)</span><br><span class="line">% 取出table中的某个字段中的某一行的数据</span><br><span class="line">data = RLCChannelConfig.RNTI(1);</span><br><span class="line">% 把table转成struct</span><br><span class="line">myStruct = table2struct(RLCChannelConfig)</span><br><span class="line">myStruct_1 = table2struct(RLCChannelConfig(1,2:end));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="对角矩阵操作"><a href="#对角矩阵操作" class="headerlink" title="对角矩阵操作"></a>对角矩阵操作</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">% 创建对角矩阵</span><br><span class="line">A = diag([1 2 3]);   % 生成对角线为 [1 2 3] 的矩阵</span><br><span class="line"></span><br><span class="line">% 提取矩阵的对角线</span><br><span class="line">d = diag(A);         % 返回 A 的主对角线</span><br><span class="line"></span><br><span class="line">% 生成偏移对角矩阵</span><br><span class="line">B = diag([4 5 6], 1);  % 将 [4 5 6] 放在主对角线上方一条对角线上</span><br><span class="line">X = diag((<span class="number">1</span>+<span class="number">1</span>i)*ones(<span class="number">1</span>,Pilot_num));   % all pilots are 1+1i.</span><br><span class="line">    </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Cell"><a href="#Cell" class="headerlink" title="Cell"></a>Cell</h2><p>Cell 是 MATLAB 中一种特殊的数据结构，可以存储不同类型或大小的数据项。与常规数组只能存储同一类型不同，Cell 非常适合用来组织杂类信息，比如混合了字符串、向量、矩阵等数据的集合。</p>
<h3 id="✅-创建-Cell-数组"><a href="#✅-创建-Cell-数组" class="headerlink" title="✅ 创建 Cell 数组"></a>✅ 创建 Cell 数组</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 创建一个空的 cell 数组</span></span><br><span class="line">x = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 分别向不同位置添加不同类型的数据</span></span><br><span class="line">x&#123;<span class="number">1</span>&#125; = <span class="number">1</span>;                  <span class="comment">% 数字标量</span></span><br><span class="line">x&#123;<span class="number">2</span>&#125; = <span class="string">&#x27;hello&#x27;</span>;            <span class="comment">% 字符串</span></span><br><span class="line">x&#123;<span class="number">3</span>&#125; = [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>];            <span class="comment">% 向量</span></span><br><span class="line">x&#123;<span class="number">4</span>&#125; = <span class="built_in">rand</span>(<span class="number">2</span>, <span class="number">2</span>);         <span class="comment">% 矩阵</span></span><br><span class="line">x&#123;<span class="number">5</span>&#125; = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>&#125;;         <span class="comment">% 嵌套 cell 数组</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="🔍-访问-Cell-中的元素"><a href="#🔍-访问-Cell-中的元素" class="headerlink" title="🔍 访问 Cell 中的元素"></a>🔍 访问 Cell 中的元素</h3><ul>
<li><p>使用 <code>&#123;&#125;</code> 获取内容本身（解包）：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val = x&#123;<span class="number">2</span>&#125;;    <span class="comment">% 返回 &#x27;hello&#x27;，类型为 char</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>()</code> 获取一个 cell（未解包）：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val = x(<span class="number">2</span>);    <span class="comment">% 返回 &#123;&#x27;hello&#x27;&#125;，类型为 1×1 cell</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="🔄-遍历-Cell-数组"><a href="#🔄-遍历-Cell-数组" class="headerlink" title="🔄 遍历 Cell 数组"></a>🔄 遍历 Cell 数组</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(x)</span><br><span class="line">    <span class="built_in">disp</span>(x&#123;<span class="built_in">i</span>&#125;);   <span class="comment">% 解包并显示每个元素</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>


<h2 id="class"><a href="#class" class="headerlink" title="class"></a>class</h2><p>假设有一个nrUE类<br>构建nrUEs数组很简单</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UEs = nrUE(Name=ueNames,Position=uePositions, Receive=11);</span><br></pre></td></tr></table></figure>
<p>只需要在传参时将数组传进去即可，这样输出自动成为数组</p>
<h2 id="size函数：-查看数组尺寸"><a href="#size函数：-查看数组尺寸" class="headerlink" title="size函数： 查看数组尺寸"></a>size函数： 查看数组尺寸</h2><p>MATLAB 中的 <code>size</code> 函数用于查看数组或矩阵的每个维度的大小。</p>
<h3 id="📘-基本用法"><a href="#📘-基本用法" class="headerlink" title="📘 基本用法"></a>📘 基本用法</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A = <span class="built_in">rand</span>(<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>);     <span class="comment">% 创建一个 4×3×2 的三维数组</span></span><br><span class="line">s = <span class="built_in">size</span>(A);           <span class="comment">% s = [4 3 2]</span></span><br></pre></td></tr></table></figure>

<h3 id="📗-查看某一维的大小"><a href="#📗-查看某一维的大小" class="headerlink" title="📗 查看某一维的大小"></a>📗 查看某一维的大小</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rows = <span class="built_in">size</span>(A, <span class="number">1</span>);     <span class="comment">% 第 1 维度大小（行数） =&gt; 4</span></span><br><span class="line">cols = <span class="built_in">size</span>(A, <span class="number">2</span>);     <span class="comment">% 第 2 维度大小（列数） =&gt; 3</span></span><br><span class="line">depth = <span class="built_in">size</span>(A, <span class="number">3</span>);    <span class="comment">% 第 3 维度大小 =&gt; 2</span></span><br></pre></td></tr></table></figure>

<h3 id="📙-示例：分析-MIMO-信号数组"><a href="#📙-示例：分析-MIMO-信号数组" class="headerlink" title="📙 示例：分析 MIMO 信号数组"></a>📙 示例：分析 MIMO 信号数组</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">inputRXSig = <span class="built_in">rand</span>(<span class="number">234</span>, <span class="number">32</span>, <span class="number">4</span>);   <span class="comment">% 子载波 × 发射天线 × 接收天线</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">size</span>(inputRXSig)</span><br><span class="line"><span class="comment">% 输出：[234  32  4]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">size</span>(inputRXSig, <span class="number">3</span>)</span><br><span class="line"><span class="comment">% 输出：4（即接收天线数）</span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://hechenyi.github.io/2025/04/24/NRTDDPerformanceEvaluation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/04/24/NRTDDPerformanceEvaluation/" class="post-title-link" itemprop="url">NRTDDPerformanceEvaluation</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2025-04-24 05:47:47 / Modified: 18:56:11" itemprop="dateCreated datePublished" datetime="2025-04-24T05:47:47+08:00">2025-04-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/5G/" itemprop="url" rel="index"><span itemprop="name">5G</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      
          <h2 id="1-Basic-Concept"><a href="#1-Basic-Concept" class="headerlink" title="1. Basic Concept"></a>1. Basic Concept</h2><p>In TDD (Time division duplexing) mode, physical uplink shared channel (PUSCH) and physical downlink shared channel (PDSCH) transmissions are scheduled in the same frequency band with separation in time domain. The scheduling strategy can be customized and network performance can be evaluated accordingly. </p>
<h3 id="1-1-举例说明"><a href="#1-1-举例说明" class="headerlink" title="1.1 举例说明"></a>1.1 举例说明</h3><p>matlab里面参数设置如下<br>reference_scs &#x3D; 15kHz(i.e. 1 ms slot), DLULPeriodicity &#x3D; 5 ms, numDLSlots &#x3D; 3, numDLSyms &#x3D; 7, numULSlots &#x3D; 1, numULSyms &#x3D; 5<br>所以Number of slots in DL-UL periodicity with respect to reference SCS of 15 kHz对应的NumSlotsDLULPeriodicity &#x3D; 5<br>最后Slot分布图如下<br>Slot Index:     0   1   2    3    4<br>            +—–+—+—-+—-+—–+<br>Slot Type:  DL     Dl   Dl    Up   UL<br>Symbol Use: full   full  7sym  full 5sym</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://hechenyi.github.io/2025/04/23/JavaSwing/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/04/23/JavaSwing/" class="post-title-link" itemprop="url">JavaSwing</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-04-23 05:20:59" itemprop="dateCreated datePublished" datetime="2025-04-23T05:20:59+08:00">2025-04-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-25 19:48:01" itemprop="dateModified" datetime="2025-04-25T19:48:01+08:00">2025-04-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      
          <h2 id="Basic-Concept"><a href="#Basic-Concept" class="headerlink" title="Basic Concept"></a>Basic Concept</h2><p>Swing is part of API for providing native look and feel GUI for Java, which has more components than AWT(Abstract Window Toolkit), and these components are more lightweight.  </p>
<p>Documents:<br><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/20/docs/api/java.desktop/javax/swing/package-summary.html">https://docs.oracle.com/en/java/javase/20/docs/api/java.desktop/javax/swing/package-summary.html</a>  </p>
<p>These components are as below:</p>
<ul>
<li>Windows and dialogs<ul>
<li>JFrame<br>  <strong>JFrame</strong>是一个<strong>顶层容器</strong>，用于创建一个窗口，窗口中可以包含按钮、文本框、标签等各种组件，并且JFrame也可以布局，例如添加BorderLayout</li>
<li>JDialog</li>
<li>JColorChooser</li>
<li>JFileChooser</li>
<li>JOptionPane</li>
</ul>
</li>
<li>Menus<ul>
<li>JMenuItem</li>
<li>JMenu</li>
<li>JMenuBar</li>
<li>JCheckBoxMenuItem</li>
<li>JRadioButtonMenuItem</li>
<li>JPopupMenu</li>
<li>JSeparator</li>
</ul>
</li>
<li>Container<ul>
<li>JPanel<br>  JPanel是面板组件，通常不单独显示，而是作为其他容器（比如JFrame）中的子容器，主要用来：组织组件（比如把按钮、文本框放在一个面板里），配合不同的布局管理器使用（FlowLayout、 BorderLayout、 GridLayout）</li>
<li>JTappedPane</li>
<li>JSplitPane</li>
<li>JScrollPane</li>
<li>JToolBar</li>
<li>JDesktopPane</li>
<li>JInternalFrame</li>
<li>JLayeredPane</li>
</ul>
</li>
<li>Control elements<ul>
<li>JLabel</li>
<li>JButton</li>
<li>JToggleButton</li>
<li>JCheckBox<br>  复选框组件，用来让用户在多个选项中进行单选或多选</li>
<li>JRadioButton</li>
<li>ButtonGroup</li>
<li>JComboBox</li>
<li>JList</li>
<li>JTextField</li>
<li>JTextArea</li>
<li>JSeperator</li>
</ul>
</li>
<li>Event handling<ul>
<li>ActionEvent</li>
<li>AdjustmentEvent</li>
<li>FocusEvent</li>
<li>ItemEvent</li>
<li>MouseEvent</li>
<li>TextEvent</li>
<li>WindowEvent</li>
<li>Menuvent</li>
<li>ListSelectionEvent</li>
<li>TableModelEvent<br>以WindowEvent为例</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">JFrame testFrame = new JFrame(<span class="string">&quot;Listener Test&quot;</span>);</span><br><span class="line">testFrame.setSize(300,200);</span><br><span class="line">testFrame.addWindowListener(new <span class="function"><span class="title">WindowAdpater</span></span>()&#123;</span><br><span class="line">    public void windowClosing(WindowEvent e)&#123;</span><br><span class="line">        JOptionPane testOpt = new JOptionPane();</span><br><span class="line">        testOpt.showMessageDialog(new JFrame(), <span class="string">&quot;closing Window!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这里使用了匿名函数，等同于以下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">JFrame testFrame = new JFrame(<span class="string">&quot;Listener Test&quot;</span>);</span><br><span class="line">class MyWindowListener extends WindowAdpater&#123;</span><br><span class="line">    public void windowClosing(WindowEvent e)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;窗口关闭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">testFrame.addWindowListener(new MyWindowListener());</span><br></pre></td></tr></table></figure>
<ul>
<li>Layout manager<ul>
<li>FlowLayout</li>
<li>GridLayout</li>
<li>BorderLayout</li>
<li>BoxLayout</li>
<li>CardLayout</li>
<li>GridBagLayout</li>
<li>GroupLayout</li>
<li>SpringLayout</li>
</ul>
</li>
</ul>
<h2 id="Java的抽象类和接口"><a href="#Java的抽象类和接口" class="headerlink" title="Java的抽象类和接口"></a>Java的抽象类和接口</h2><p>以抽象类WindowAdapter和接口WindowListener为例。<br>通常来说，抽象类继承了接口的方法，但是每个方法都留了个空壳实现，正因为这些空壳，继承了接口的抽象类只需要写像覆盖的那几种方法，而不是被迫写完全部。<br>例如WindowAdapter继承WindowListener</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public abstract class WindowAdapter implements WindowListener&#123;</span><br><span class="line">    public void windowOpened(WindowEvent e)&#123;&#125;</span><br><span class="line">    ...</span><br><span class="line">    public void windowDeactivated(WindowEvent e)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用继承的方法构建MainFrame类"><a href="#使用继承的方法构建MainFrame类" class="headerlink" title="使用继承的方法构建MainFrame类"></a>使用继承的方法构建MainFrame类</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class MainFrame extends JFrame&#123;</span><br><span class="line">    public <span class="function"><span class="title">MainFrame</span></span>()&#123;</span><br><span class="line">        setTitle(<span class="string">&quot;Choose Your Favorite Items&quot;</span>);</span><br><span class="line">        setSize(400, 300);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以这么理解,以下的JFrame父类的构造函数会在子类MainFrame调用构造函数时被调用，因为如果父类构造函数如果是无参的话那么就会被隐型调用，如果是有参的话需要通过super函数来调用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class JFrame&#123;</span><br><span class="line">    public <span class="function"><span class="title">JFrame</span></span>()&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>继承了这个父类的MyFrame子类相当于在构造函数里面执行了一遍super()</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public <span class="function"><span class="title">MainFrame</span></span>()&#123;</span><br><span class="line">    super();</span><br><span class="line">    setTitle(<span class="string">&quot;Choose your favourite items&quot;</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<img src="/images/你.jpg">
你好可爱，为什么我们性格会如何相像

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://hechenyi.github.io/2025/04/22/openairinterface/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/04/22/openairinterface/" class="post-title-link" itemprop="url">openairinterface</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-04-22 17:45:43" itemprop="dateCreated datePublished" datetime="2025-04-22T17:45:43+08:00">2025-04-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-31 21:42:00" itemprop="dateModified" datetime="2025-05-31T21:42:00+08:00">2025-05-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/5G/" itemprop="url" rel="index"><span itemprop="name">5G</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      
          <h2 id="openairinterface"><a href="#openairinterface" class="headerlink" title="openairinterface"></a>openairinterface</h2><h3 id="PHY-MODULATION"><a href="#PHY-MODULATION" class="headerlink" title="PHY&#x2F;MODULATION&#x2F;"></a>PHY&#x2F;MODULATION&#x2F;</h3><h4 id="slot-fep-nr-c"><a href="#slot-fep-nr-c" class="headerlink" title="slot_fep_nr.c"></a>slot_fep_nr.c</h4><p><strong>nr_slot_fep_init_sync</strong> function 是5G NR UE PHY层的一个函数，主要功能是针对某个指定的slot和OFDM符号<br>分为以下几个部分:</p>
<ul>
<li>从时域采样中提取该符号的样本</li>
<li>做DFT转换 （时域-&gt;频域）</li>
<li>对频域符号进行旋转补偿(symbol rotation)</li>
<li>将频域结果存入缓冲区，为后续处理（解调，测量等）做准备</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/// 获取当前ofdm符号在时域中的rx_offset</span><br><span class="line">/// 其中is * fp-&gt;samples_per_frame前面所有frame的采样点数目</span><br><span class="line">nr_slot_fep_init_sync(ue, proc, i, j, is * fp-&gt;samples_per_frame + ue-&gt;ssb_offset);</span><br><span class="line">/// nr_slot_fep_init_sync函数内部</span><br><span class="line">/// 其中Ns表示Slot数，symbol表示符号数，从而可以使得对每个符号都能做处理</span><br><span class="line">unsigned int slot_offset = frame_parms-&gt;get_samples_slot_timestamp(Ns,frame_parms,0);</span><br><span class="line">unsigned int rx_offset   = sample_offset + slot_offset;</span><br><span class="line">unsigned int abs_symbol  = Ns * frame_parms-&gt;symbols_per_slot + symbol;</span><br><span class="line"><span class="keyword">for</span> (int idx_symb = Ns*frame_parms-&gt;symbols_per_slot; idx_symb &lt;= abs_symbol; idx_symb++)</span><br><span class="line"></span><br><span class="line">    rx_offset += (abs_symbol%(0x7&lt;&lt;<span class="string">frame_parms-&gt;numerology_index)) ? nb_prefix_samples : nb_prefix_samples0;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/// 最后，再加上当前 slot 内的 symbol 个数 * 每个符号的数据长度（不含 CP）  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">rx_offset += frame_parms</span>-&gt;ofdm_symbol_size * symbol;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>由代码可知rx_offset计算了到当前帧中某个 slot 内某个 OFDM 符号在时域（采样）数据中的精确位置（采样点数）”。<br>它考虑了所有采样数据偏移（包含cp）</p>
<p>这个计算而来的rx_offset后面会被用于更新时间戳，会将RF接收链中的采样时间戳向前推进<strong>rx_offset_sl</strong>个采样点，确保后续的解调&#x2F;解码从正确位置开始,具体可见下面<strong>syncInFrame</strong>函数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void syncInFrame(PHY_VARS_NR_UE *UE, openair0_timestamp *timestamp) &#123;</span><br><span class="line">    int rx_offset = (get_softmodem_params()-&gt;sl_mode == 2) ? UE-&gt;rx_offset_sl : UE-&gt;rx_offset;</span><br><span class="line">    LOG_I(NR_PHY, <span class="string">&quot;Resynchronizing RX by %d samples (mode = %d)\n&quot;</span>, rx_offset, UE-&gt;mode);</span><br><span class="line">    *timestamp += UE-&gt;frame_parms.get_samples_per_slot(1,&amp;UE-&gt;frame_parms);</span><br><span class="line">    <span class="keyword">for</span> (int size = rx_offset; size &gt; 0; size -= UE-&gt;frame_parms.samples_per_subframe) &#123;</span><br><span class="line">      int unitTransfer=size&gt;UE-&gt;frame_parms.samples_per_subframe ? UE-&gt;frame_parms.samples_per_subframe : size ;</span><br><span class="line">      // we write before <span class="built_in">read</span> because gNB waits <span class="keyword">for</span> UE to write and both executions halt</span><br><span class="line">      // this happens here as the <span class="built_in">read</span> size is samples_per_subframe <span class="built_in">which</span> is very much larger than samp_per_slot</span><br><span class="line">      <span class="keyword">if</span> (IS_SOFTMODEM_RFSIM &amp;&amp; !get_softmodem_params()-&gt;sync_ref) dummyWrite(UE,*timestamp, unitTransfer);</span><br><span class="line">      AssertFatal(unitTransfer ==</span><br><span class="line">                  UE-&gt;rfdevice.trx_read_func(&amp;UE-&gt;rfdevice,</span><br><span class="line">                                             timestamp,</span><br><span class="line">                                             (void **)UE-&gt;common_vars.rxdata,</span><br><span class="line">                                             unitTransfer,</span><br><span class="line">                                             UE-&gt;frame_parms.nb_antennas_rx),<span class="string">&quot;&quot;</span>);</span><br><span class="line">      *timestamp += unitTransfer; // this does not affect the <span class="built_in">read</span> but needed <span class="keyword">for</span> RFSIM write</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码可见，每次处理sample_per_subframe 数目的数据，然后更新timestamp时间戳，最后将timestamp加上了rx_offset,需要注意的的是对于需要跳过的数据也需要进行<strong>rfdevice.trx_read_func</strong>处理，因为RF采集的数据是流式的，数据是连续产生并存放到硬件缓冲区里的。</p>
<hr>
<blockquote>
<p><strong>Notice</strong><br><br>一个OFDM符号的采样点数量（不包含cp）等于FFT size，<br>也就说FFT size不包含cp，但是在计算时域上的offset时需要考虑cp，正如上述代码所示</p>
</blockquote>
<hr>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/// 根据rx_offset取出rxdata</span><br><span class="line">  <span class="keyword">for</span> (unsigned char aa=0; aa&lt;frame_parms-&gt;nb_antennas_rx; aa++) &#123;</span><br><span class="line">    memset(&amp;common_vars-&gt;common_vars_rx_data_per_thread[proc-&gt;thread_id].rxdataF[aa][frame_parms-&gt;ofdm_symbol_size*symbol],0,frame_parms-&gt;ofdm_symbol_size*sizeof(int32_t));</span><br><span class="line"></span><br><span class="line">    int16_t *rxdata_ptr;</span><br><span class="line">    rx_offset%=frame_length_samples*2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rx_offset+frame_parms-&gt;ofdm_symbol_size &gt; frame_length_samples*2 ) &#123;</span><br><span class="line">      // rxdata is 2 frames len</span><br><span class="line">      // we have to wrap on the end</span><br><span class="line"></span><br><span class="line">      memcpy((void *)&amp;tmp_dft_in[<span class="number">0</span>],</span><br><span class="line">             (void *)&amp;common_vars-&gt;rxdata[aa][rx_offset],</span><br><span class="line">             (frame_length_samples*<span class="number">2</span> - rx_offset) * sizeof(int32_t));</span><br><span class="line">      memcpy((void *)&amp;tmp_dft_in[frame_length_samples*<span class="number">2</span> - rx_offset],</span><br><span class="line">             (void *)&amp;common_vars-&gt;rxdata[aa][<span class="number">0</span>],</span><br><span class="line">             (frame_parms-&gt;ofdm_symbol_size - (frame_length_samples*<span class="number">2</span> - rx_offset)) * sizeof(int32_t));</span><br><span class="line">      rxdata_ptr = (int16_t *)tmp_dft_in;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((rx_offset &amp; <span class="number">7</span>) != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">      // if input to dft is not <span class="number">256</span>-bit aligned</span><br><span class="line">      memcpy((void *)&amp;tmp_dft_in[<span class="number">0</span>],</span><br><span class="line">             (void *)&amp;common_vars-&gt;rxdata[aa][rx_offset],</span><br><span class="line">             frame_parms-&gt;ofdm_symbol_size * sizeof(int32_t));</span><br><span class="line">      rxdata_ptr = (int16_t *)tmp_dft_in;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">      // use dft input from RX buffer directly</span><br><span class="line">      rxdata_ptr = (int16_t *)&amp;common_vars-&gt;rxdata[aa][rx_offset];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">/// 调用dft()函数做时域到频域转换，输出存到rxdataF缓冲区</span><br><span class="line">dft(dftsize,</span><br><span class="line">    rxdata_ptr,</span><br><span class="line">    (int16_t *)&amp;common_vars-&gt;common_vars_rx_data_per_thread[proc-&gt;thread_id].rxdataF[aa][frame_parms-&gt;ofdm_symbol_size*symbol],</span><br><span class="line">    1);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="rxdata-时域采样数据-和-rxdataF-（频域符号数据）"><a href="#rxdata-时域采样数据-和-rxdataF-（频域符号数据）" class="headerlink" title="rxdata (时域采样数据) 和 rxdataF （频域符号数据）"></a>rxdata (时域采样数据) 和 rxdataF （频域符号数据）</h5><p>rxdata<br>每两个int16_t是一个复数采样(I + jQ)</p>
<p>| I1 | Q1 | I2 | Q2 | I3 | Q3 | I4 | Q4 | …  (时域采样序列)<br>|—-|—-|—-|—-|—-|—-|—-|—-|<br>  t0   t0  t1   t1  t2   t2  t3   t3     时间顺序采样点</p>
<p>rxdataF<br>每两个int16_t是一个子载波的频域复数系数  </p>
<p>| Re(k&#x3D;0) | Im(k&#x3D;0) | Re(k&#x3D;1) | Im(k&#x3D;1) | Re(k&#x3D;2) | Im(k&#x3D;2) | … (频域子载波序列)<br>|———|———|———|———|———|———|<br>  子载波0    子载波0    子载波1    子载波1    子载波2    子载波2</p>
<h3 id="executable"><a href="#executable" class="headerlink" title="executable"></a>executable</h3><p>里面有多个与build后生成的可执行文件同名的.h和.c文件，例如nr-uesoftmodem.c，相当于在执行nr-uesoftmodem后就会去这个c文件里找主函数，然后依次运行。</p>
<h4 id="softmodem-common-h"><a href="#softmodem-common-h" class="headerlink" title="softmodem-common.h"></a>softmodem-common.h</h4><ul>
<li>第一步，先#define CMDLINE_PARAMS_DESC,用于将终端传入的参数放入一个临时变量中</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define CMDLINE_PARAMS_DESC &#123;  \</span></span><br><span class="line">    &#123;<span class="string">&quot;rf-config-file&quot;</span>,       CONFIG_HLP_RFCFGF,       0,              strptr:&amp;RF_CONFIG_FILE,             defstrval:NULL,        TYPE_STRING, 0&#125;,                     \</span><br><span class="line">    &#123;<span class="string">&quot;split73&quot;</span>,              CONFIG_HLP_SPLIT73,      0,              strptr:&amp;SPLIT73,                    defstrval:NULL,        TYPE_STRING, 0&#125;,                     \</span><br><span class="line">    &#123;<span class="string">&quot;thread-pool&quot;</span>,          CONFIG_HLP_TPOOL,        0,              strptr:&amp;TP_CONFIG,                  defstrval:<span class="string">&quot;-1,-1,-1,-1,-1,-1,-1,-1&quot;</span>, TYPE_STRING, 0&#125;,       \</span><br><span class="line">    &#123;<span class="string">&quot;phy-test&quot;</span>,             CONFIG_HLP_PHYTST,       PARAMFLAG_BOOL, iptr:&amp;PHY_TEST,                     defintval:0,           TYPE_INT,    0&#125;,                     \</span><br><span class="line">    &#123;<span class="string">&quot;sl-phy-test&quot;</span>,          CONFIG_HLP_SL_PHYTST,    PARAMFLAG_BOOL, iptr:&amp; </span><br><span class="line">    ....</span><br><span class="line">    TUNE_OFFSET,                defintval:0,           TYPE_DOUBLE, 0&#125;,                     \</span><br><span class="line">    &#123;<span class="string">&quot;wait-for-sync&quot;</span>,        NULL,                    PARAMFLAG_BOOL, iptr:&amp;WAIT_FOR_SYNC,                defintval:0,           TYPE_INT,    0&#125;,                     \</span><br><span class="line">    &#123;<span class="string">&quot;single-thread-enable&quot;</span>, CONFIG_HLP_NOSNGLT,      PARAMFLAG_BOOL, iptr:&amp;SINGLE_THREAD_FLAG,           defintval:0,           TYPE_INT,    0&#125;,                     \</span><br><span class="line">    &#123;<span class="string">&quot;C&quot;</span> ,                   CONFIG_HLP_DLF,          0,              u64ptr:&amp;(downlink_frequency[0][0]), defuintval:3600000000, TYPE_UINT64, 0&#125;,                     \</span><br><span class="line">    &#123;<span class="string">&quot;CO&quot;</span> ,                  CONFIG_HLP_ULF,          0,              iptr:&amp;(uplink_frequency_offset[0][0]), defintval:0,        TYPE_INT,    0&#125;,                     \</span><br><span class="line">    &#123;<span class="string">&quot;a&quot;</span> ,                   CONFIG_HLP_CHOFF,        0,              iptr:&amp;CHAIN_OFFSET,                 defintval:0,           TYPE_INT,    0&#125;,                     \</span><br><span class="line">    &#123;<span class="string">&quot;d&quot;</span> ,                   CONFIG_HLP_SOFTS,        PARAMFLAG_BOOL, uptr:(uint32_t *)&amp;do_forms,         defintval:0,           TYPE_INT8,   0&#125;,                     \</span><br><span class="line">    &#123;<span class="string">&quot;q&quot;</span> ,                   CONFIG_HLP_STMON,        PARAMFLAG_BOOL, iptr:&amp;opp_enabled,                  defintval:0,           TYPE_INT,    0&#125;,                     \</span><br><span class="line">    &#123;<span class="string">&quot;numerology&quot;</span> ,          CONFIG_HLP_NUMEROLOGY,   PARAMFLAG_BOOL, iptr:&amp;NUMEROLOGY,                   defintval:1,           TYPE_INT,    0&#125;,                     \</span><br><span class="line">    &#123;<span class="string">&quot;band&quot;</span> ,                CONFIG_HLP_BAND,         0,              iptr:&amp;BAND,                         defintval:78,          TYPE_INT,    0&#125;,                     \</span><br><span class="line">    &#123;<span class="string">&quot;emulate-rf&quot;</span> ,          CONFIG_HLP_EMULATE_RF,   PARAMFLAG_BOOL, iptr:&amp;EMULATE_RF,                   defintval:0,           TYPE_INT,    0&#125;,                     \</span><br><span class="line">    &#123;<span class="string">&quot;parallel-config&quot;</span>,      CONFIG_HLP_PARALLEL_CMD, 0,              strptr:&amp;parallel_config,            defstrval:NULL,        TYPE_STRING, 0&#125;,                     \</span><br><span class="line">    &#123;<span class="string">&quot;worker-config&quot;</span>,        CONFIG_HLP_WORKER_CMD,   0,              strptr:&amp;worker_config,              defstrval:NULL,        TYPE_STRING, 0&#125;,                     \</span><br><span class="line">    &#123;<span class="string">&quot;noS1&quot;</span>,                 CONFIG_HLP_NOS1,         PARAMFLAG_BOOL, uptr:&amp;noS1,                         defintval:0,           TYPE_INT,    0&#125;,                     \</span><br><span class="line">    &#123;<span class="string">&quot;rfsim&quot;</span>,                CONFIG_HLP_RFSIM,        PARAMFLAG_BOOL, uptr:&amp;rfsim,                        defintval:0,           TYPE_INT,    0&#125;,                     \</span><br><span class="line">    &#123;<span class="string">&quot;nokrnmod&quot;</span>,             CONFIG_HLP_NOKRNMOD,     PARAMFLAG_BOOL, uptr:&amp;nokrnmod,                     defintval:0,           TYPE_INT,    0&#125;,                     \</span><br><span class="line">    &#123;<span class="string">&quot;nbiot-disable&quot;</span>,        CONFIG_HLP_DISABLNBIOT,  PARAMFLAG_BOOL, uptr:&amp;nonbiot,                      defuintval:0,          TYPE_INT,    0&#125;,                     \</span><br><span class="line">    &#123;<span class="string">&quot;chest-freq&quot;</span>,           CONFIG_HLP_CHESTFREQ,    0,              iptr:&amp;SYNC_REF,                     defintval:0,           TYPE_INT,    0&#125;,                     \</span><br><span class="line">    &#123;<span class="string">&quot;nid1&quot;</span>,                 CONFIG_HLP_NID1,         0,              iptr:&amp;NID1,                         defintval:10,          TYPE_INT,    0&#125;,                     \</span><br><span class="line">    &#123;<span class="string">&quot;nid2&quot;</span>,                 CONFIG_HLP_NID2,         0,              iptr:&amp;NID2,                         defintval:1,           TYPE_INT,    0&#125;,                     \</span><br><span class="line">    &#123;<span class="string">&quot;message&quot;</span>,              CONFIG_HLP_MSG,          0,              strptr:&amp;SL_USER_MSG,                defstrval:NULL,        TYPE_STRING, 0&#125;,                     \</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>第二步，将临时变量放入结构体变量中，用于后续调用</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define NODE_NUMBER         softmodem_params.node_number</span></span><br><span class="line"><span class="comment">#define SL_DEST_ID          softmodem_params.dest_id</span></span><br><span class="line"><span class="comment">#define NON_STOP            softmodem_params.non_stop</span></span><br><span class="line"><span class="comment">#define EMULATE_L1          softmodem_params.emulate_l1</span></span><br><span class="line"><span class="comment">#define CONTINUOUS_TX       softmodem_params.continuous_tx</span></span><br><span class="line"><span class="comment">#define SYNC_REF            softmodem_params.sync_ref</span></span><br><span class="line"><span class="comment">#define NID1                softmodem_params.nid1</span></span><br><span class="line"><span class="comment">#define NID2                softmodem_params.nid2</span></span><br><span class="line"><span class="comment">#define SL_USER_MSG         softmodem_params.sl_user_msg</span></span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="调用nr-uesoftmodem-c"><a href="#调用nr-uesoftmodem-c" class="headerlink" title="调用nr-uesoftmodem.c"></a>调用nr-uesoftmodem.c</h4><h5 id="调用UE-thread-SL"><a href="#调用UE-thread-SL" class="headerlink" title="调用UE_thread_SL"></a>调用UE_thread_SL</h5><ul>
<li><p>Initialization</p>
<ul>
<li>初始化UE</li>
<li>收发缓冲区指针</li>
<li>射频设备设置</li>
<li>FIFO初始化<br>  初始化一个命名为nf的<strong>notifiedFIFO</strong>,这是一个线程安全的FIFO（先进先出）队列，用于管理从工作线程（线程池Tpool中）返回的结果。工作线程在完成时隙处理任务后会通知这个FIFI<br>  初始化一个命名为freeBlocks的notifiedFIFO，这个队列将持有预先分配好的数据结构<strong>nr_rxtx_thread_data_t</strong>,准备用于处理即将到来的时隙。使用预先分配块可以避免在主循环中频繁进行内存分配和释放</li>
<li>初始化变量，包括sync_running_sl等标识位</li>
</ul>
</li>
<li><p>预分配处理块（pre-allocate processing blocks）<br>这里使用了FIFO任务队列，具体来说构建了TPool线程池，然后还构建了一个FIFO任务队列，队列中每个成员是一个任务结构体，里面包含一个任务函数 + msgdata</p>
<ul>
<li>notifiedFIFO<br>  这个队列是用来管理任务队列</li>
</ul>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct notifiedFIFO&#123;</span><br><span class="line">    /// 队列的尾部（用于入列）</span><br><span class="line">    notifiedFIFO_elt_t *inF;</span><br><span class="line">    /// 队列的头部（用于出列）</span><br><span class="line">    notifiedFIFO_elt_t *outF;</span><br><span class="line"></span><br><span class="line">&#125; notifiedFIFO_t;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>newNotifiedFIFO_elt, notifiedFIFO_elt结构体是notifiedFIFO队列的成员，也就是每一个任务元素，里面包含任务函数还有数据。为了队列中的一个元素分配内存，并为其提供一些额外的功能（比如存储msgData，并确保数据对齐以便SIMD处理）</li>
</ul>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct notifiedFIFO_elt_s&#123;</span><br><span class="line"></span><br><span class="line">    struct notifiedFIFO_elt_s *next;</span><br><span class="line">    void (*processingFunc) (void *);</span><br><span class="line">    void *msgData;</span><br><span class="line">    ...</span><br><span class="line">&#125; notifiedFIFO_elt_t;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>pushNotifiedFIFO_nothreadSafe<br>  这段代码实现的是一个非线程安全的队列操作，具体是将一个新的元素（notifiedFIFO_elt_t *msg）推入队列(notifiedFIFO_t *nf)的末尾，它的功能是将<strong>msg</strong>添加到一个名为<strong>notifiedFIFO_t</strong>的队列中， 并维护队列的入口和出口指针</li>
</ul>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pushNotifiedFIFO_nothreadSafe(notifiedFIFO_t *nf, notifiedFIFO_elt_t *msg)&#123;</span><br><span class="line">    msg-&gt;next = NULL;</span><br><span class="line">    <span class="keyword">if</span>(nf-&gt;outF == NULL)</span><br><span class="line">    nf-&gt;outF = msg;</span><br><span class="line">    <span class="keyword">if</span>(nf-&gt;inF != NULL)</span><br><span class="line">    nf-&gt;inF-&gt;next = msg;</span><br><span class="line">    </span><br><span class="line">    nf-&gt;inF = msg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>pushTpool<br>  这个函数的目的是将任务添加到线程池中，并根据线程池的状态决定任务的处理方式。具体来说，它有两种处理方式：1. 线程池已激活时，任务会被放入队列，等待工作线程从队列中取出并执行。2. 线程池未激活时，任务会在当前线程中理解执行。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">static inline void pushTpool(tpool_t *t, notifiedFIFO_elt_t *msg)&#123;</span><br><span class="line">  <span class="keyword">if</span> (t-&gt;measurePerf) msg-&gt;creationTime=rdtsc_oai();</span><br><span class="line">    <span class="keyword">if</span> ( t-&gt;activated)</span><br><span class="line">        pushNotifiedFIFO(&amp;t-&gt;incomingFifo, msg);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (t-&gt;measurePerf)</span><br><span class="line">         msg-&gt;startProcessingTime=rdtsc_oai();</span><br><span class="line"></span><br><span class="line">            msg-&gt;processingFunc(NotifiedFifoData(msg));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (t-&gt;measurePerf)</span><br><span class="line">        msg-&gt;endProcessingTime=rdtsc_oai();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (msg-&gt;reponseFifo)</span><br><span class="line">            pushNotifiedFIFO(msg-&gt;reponseFifo, msg);</span><br><span class="line">        &#125;         </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>pullTpool<br>  这个函数是将线程池响应队列中拉取任务.</li>
</ul>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  static inline notifiedFIFO_elt_t *pullTpool(notifiedFIFO_t *responseFifo, tpool_t *t) &#123;</span><br><span class="line">notifiedFIFO_elt_t *msg= pullNotifiedFIFO(responseFifo);</span><br><span class="line"><span class="keyword">if</span> (msg == NULL)</span><br><span class="line">  <span class="built_in">return</span> NULL;</span><br><span class="line">AssertFatal(t-&gt;traceFd, <span class="string">&quot;Thread pool used while not initialized&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (t-&gt;measurePerf)</span><br><span class="line">  msg-&gt;returnTime=rdtsc_oai();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (t-&gt;traceFd &gt; 0)</span><br><span class="line">  <span class="keyword">if</span>(write(t-&gt;traceFd, msg, sizeof(*msg)));</span><br><span class="line"></span><br><span class="line"><span class="built_in">return</span> msg;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="Tx-Sync-UE"><a href="#Tx-Sync-UE" class="headerlink" title="Tx(Sync UE)"></a>Tx(Sync UE)</h5><ul>
<li>processSlotTx<br>如果sl_mode &#x3D;&#x3D; 2,会调用phy_procedures_nrUE_SL_TX</li>
<li>phy_procedures_nrUE_SL_TX(时隙控制来发射S-SSB和SCH，具体可见<strong>5gNRSidelink</strong>)<ul>
<li>phy_ssb_slot_allocation_sl（前提是sync_ref&#x3D;&#x3D;1）<br>  发射S-SSB</li>
<li>nr-ue-set-slsch(前提是sync_ref&#x3D;&#x3D;1)<br>  配置slsch</li>
<li>nr-ue_slsch_tx_procedures(前提是sync_ref&#x3D;&#x3D;1)<br>  uint32_t sl_bitmap_tx &#x3D; 0x00000;<br>  if(ue-&gt;sync_ref){<br>  sl_bitmap_tx &#x3D; (ue-&gt;is_synchronized_sl &#x3D;&#x3D; 0) ? 0x00001:0x00002;<br>  }<br>  发射slsch</li>
</ul>
</li>
</ul>
<h5 id="Rx-Nearby-UE"><a href="#Rx-Nearby-UE" class="headerlink" title="Rx(Nearby UE)"></a>Rx(Nearby UE)</h5><ul>
<li>第一步，先include &lt;nr-uesoftmode.h&gt;(里面extern了nr-ue.c里的函数)</li>
<li>第二步，get_optins</li>
<li>init_NR_UE</li>
<li>set_options(包括max_ldpc_iterations, tx_total_gain_dB等等)</li>
<li>nr_phy_config_request_sl(传参来配置PHY层的UE)<br>配置nrUE_config（用于存储通过 FAPI 接口传递给 PHY 层的配置信息（如频率、带宽、SSB 配置等）。）和ue，例如配置nrUE_config-&gt;ssb,<br>  nrUE_config-&gt;carrier_config.sl_frequency<br>  UE-&gt;sync_ref,<br>  UE-&gt;configured<br>  UE-&gt;synchronized</li>
<li>init_nr_ue_vars（关掉MAC，无需经过gNB，因此不需要传统的MAC层处理，比如调度、DCI、HARQ，反而通常是直接使用物理层进行广播或点对对通信）</li>
<li>init_openair0</li>
<li>init_NR_UE_threads(nrUE)  <ul>
<li><p>threadCreate</p>
</li>
<li><p>UE_thread_SL(里面有UE_synch和processSlotRX两个子线程，由线程池Tpool进行维护)</p>
</li>
<li><p>processSlotRX</p>
</li>
<li><p>phy_procedures_nrUE_SL_RX<br>这个函数主要判断ue是否需要执行对rx slot的处理，具体可见如下代码</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">这里可以防止<span class="built_in">sync</span> ue来执行这个接受函数，并且使得nearbyue只能在同步之后将is_synchronized_sl=1后才会执行.</span><br><span class="line"><span class="keyword">if</span>(ue-&gt;is_synchronized_sl == 0)</span><br><span class="line">  <span class="built_in">return</span> (0);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>（ue-&gt;sync_ref == 0）  </span><br><span class="line">uint32_t sl_bitmap_rx = ue-&gt;sync_ref  ? 0x00001 : 0x00002;</span><br><span class="line"><span class="keyword">if</span>(((sl_bitmap_rx = ue-&gt;sync_ref?) &amp; <span class="number">1</span> ) == <span class="number">0</span> )</span><br><span class="line">return(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>在找到正确的frame和slot后，会执行nr_ue_slsch_rx_procedures函数，这个函数体内会具体对PSSCH进行处理，包括demapping和descrambling以及decoding(nr_slsch_decoding)，这个docoding包括对SLSCH和SCI2的解码<br>为了表示每一个收到的的frame，我们在nr_slsch_decoding函数里面LOG_I(frame,slot), beacuse each frame received will go through the process in nr_slsch_decoding, be careful that not each frame received will go through the <strong>validate_rx_str</strong> function, beacuse it should satisfy a prerequirement (destination is matched). </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/// 正常情况下的LOG_I</span><br><span class="line">[NR_PHY]In nr_ue_sl_pssch_rsrp_measurements: </span><br><span class="line">[NR_PHY]SLSCH received ok</span><br><span class="line">[PHY] Frame:..., Slot:...</span><br><span class="line">[NR_PHY] Received your text!...</span><br><span class="line">[PHY] PSSCH <span class="built_in">test</span> ...f</span><br></pre></td></tr></table></figure>
<p>其中SLSCH received ok不一定执行(it is in nr_ue_sl_postDocode function after polar_decoded_int16 and it has a prerequisited that all segments are done), and these two funcations are all in the <strong>nr_slsch_decoding</strong> function.<br>Received your text is in the <strong>valdiate_rx_str</strong> function, and has a prerequisit that the dest is matched.</p>
<p>openair1&#x2F;SCHED_NR_UE&#x2F;phy_procedures_nr_ue.c中,调用nr_ue_slsch_rx_procedures来return ret</p>
<ul>
<li>nr_ue_slsch_rx_procedures(在openair1&#x2F;PHY&#x2F;NR_UE_TRANSPORT&#x2F;nl_slsch_ue.c)<ul>
<li>nr_slsch_decoding(在nr_ue_slsch_rx_procedures中，decoding的部分是sci2部分 <strong>return ret</strong>)<ul>
<li>polar_decoder_int16(在nr_slsch_decoding函数中)</li>
<li>LOG_E(NR_PHY, “polar_decoder_int16 failed with ret %d for slot %d\n”, decoder_state, nr_slot_rx);</li>
<li>return ret</li>
</ul>
</li>
</ul>
</li>
<li>validate_rx_payload(log(“PSSCH test”))</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="ci-script部分"><a href="#ci-script部分" class="headerlink" title="ci-script部分"></a>ci-script部分</h2><h3 id="sl-check-log-py"><a href="#sl-check-log-py" class="headerlink" title="sl_check_log.py"></a>sl_check_log.py</h3><p>根据nearby.log中”PSSCH test”字段进行检查，将”PSSCH test OK with 1 &#x2F; 2 &#x3D; 0.50”中的1放入nb_decoded,将2放入total_rx, 由于是for循环一直检查nearby.log，而且每个循环内会直接把int型数据覆盖给nb_decoded,”nb_decoded &#x3D; int(field[-5])”,因此会把log里的最后一条数据传给nb_decoded。同时nb_decoded_list也是只最后一条数据的list，例如nb_decoded_list&#x3D;[1]，同理total_rx_list&#x3D;[103]</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/blog/page/3/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/blog/">1</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/blog/page/5/">5</a><a class="extend next" rel="next" href="/blog/page/5/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">46</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">categories</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>

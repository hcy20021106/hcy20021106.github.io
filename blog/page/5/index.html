<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"hechenyi.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://hechenyi.github.io/blog/page/5/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://hechenyi.github.io/blog/page/5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://hechenyi.github.io/2025/04/21/5gNRUplink/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/04/21/5gNRUplink/" class="post-title-link" itemprop="url">5gNRUplink</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-04-21 20:50:40" itemprop="dateCreated datePublished" datetime="2025-04-21T20:50:40+08:00">2025-04-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-24 18:57:30" itemprop="dateModified" datetime="2025-04-24T18:57:30+08:00">2025-04-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/5G/" itemprop="url" rel="index"><span itemprop="name">5G</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      
          <h2 id="Basic-discription"><a href="#Basic-discription" class="headerlink" title="Basic discription"></a>Basic discription</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openExample(<span class="string">&#x27;5g/NRUplinkWaveformGenerationExample&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>This example shows how to configure and generate a 5G NR uplink vector waveform with physical uplink shared channel (PUSCH) and <strong>sounding reference signal</strong>(SRS).</p>
<ul>
<li>PUSCH and its assoicated demodulation reference signal (DM-RS) and phase-tracking reference signal (PT-RS)  </li>
<li>SRS</li>
</ul>
<h2 id="Steps"><a href="#Steps" class="headerlink" title="Steps"></a>Steps</h2><ul>
<li>初始化nrULCarrierConfig并配置基本参数</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">waveconfig = nrULCarrierConfig;</span><br><span class="line">waveconfig.NumSubframes = 10;</span><br><span class="line">waveconfig.FrequencyRange = <span class="string">&#x27;FR1&#x27;</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>配置scs</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scscarriers = &#123;nrSCSCarrierConfig, nrSCSCarrierConfig&#125;;</span><br><span class="line">scscarriers&#123;1&#125;.SubcarrierSpacing = 15;</span><br><span class="line">scscarriers&#123;1&#125;.NSizeGrid = 216;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>配置BWP</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bwp&#123;1&#125;.SubcarrierSpacing = 15;</span><br><span class="line">bwp&#123;1&#125;.CyclicPrefix = <span class="string">&#x27;Normal&#x27;</span>;</span><br><span class="line">bwp&#123;1&#125;.NSizeBWP = 25;   % Size of BWP <span class="keyword">in</span> PRBs</span><br><span class="line">bwp&#123;1&#125;.NStartBWP = 10;  % Position of BWP, relateive to point A.</span><br></pre></td></tr></table></figure>
<ul>
<li>配置PUSCH</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">pusch = &#123;nrWavegenPUSCHConfig&#125;;</span><br><span class="line">pusch&#123;1&#125;.Coding = 1;    % 启用UL-SCH的信道编码(LDPC编码)</span><br><span class="line">pusch&#123;1&#125;.NID    = 1;    % Scrambling（扰码）所用的NID，确保不同用户的上行数据在解码时不会混淆</span><br><span class="line">pusch&#123;1&#125;.TransformPrecoding = <span class="literal">false</span>;    % 使用CP-OFDM（DFT只适用于某些低频场景）</span><br><span class="line">pusch&#123;1&#125;.Modulation = <span class="string">&#x27;QPSK&#x27;</span>;</span><br><span class="line">pusch&#123;1&#125;.NumLayers  = 2;</span><br><span class="line">pusch&#123;1&#125;.NumAntennaPorts    = 4;</span><br><span class="line">pusch&#123;1&#125;.DataSource = <span class="string">&#x27;PN9&#x27;</span> % Channel data <span class="built_in">source</span></span><br><span class="line">pusch&#123;1&#125;.SymbolAllocation   = [0 14];   % 说明一个slot有14个OFDM symbols</span><br><span class="line">pusch&#123;1&#125;.SlotAllocation = [0 1];        % 说明一个pusch占两个Slot</span><br><span class="line">pusch&#123;1&#125;.period         = 5;            % 说明每5个slot会重复一次PUSCH分配，第0周期：slot 0 和 slot 1，第1周期： slot 5 和 slot 6</span><br><span class="line">pusch&#123;1&#125;.PRBSet         = 0:10          % 说明占用PRB数目，从而说明带宽大小</span><br><span class="line">% DM-RS configuration</span><br><span class="line">pusch&#123;1&#125;.DMRSPower      = 0;</span><br><span class="line">pusch&#123;1&#125;.DMRS.DMRSLength    = 1;</span><br><span class="line">...</span><br><span class="line">pusch&#123;1&#125;.DMRS.NSCID         = 0;</span><br><span class="line">% PT-RS configuration</span><br><span class="line">pusch&#123;1&#125;.EnablePTRS =   0;</span><br><span class="line">pusch&#123;1&#125;.PTRSPower  =   0;</span><br><span class="line">pusch&#123;1&#125;.PTRS.TimeDensity   =   1;</span><br><span class="line">pusch&#123;1&#125;.PTRS.FrequencyDensity   =   2;</span><br><span class="line">pusch&#123;1&#125;.PTRS.NumPTRSSamples =   2;</span><br><span class="line">pusch&#123;1&#125;.PTRS.PTRSPortSet   =   0;</span><br><span class="line">pusch&#123;1&#125;.PTRS.NID   =   0;</span><br><span class="line">% UCI(Uplink Control Information)</span><br><span class="line">pusch&#123;1&#125;.EnableACK  =   <span class="literal">true</span>;   % Enable or <span class="built_in">disable</span> HARQ-ACK</span><br><span class="line">pusch&#123;1&#125;.NumACKBits =   5</span><br><span class="line">pusch&#123;1&#125;.BetaOffsetCSI1 = 2     % Power <span class="built_in">factor</span> of CSI part 1</span><br><span class="line">pusch&#123;1&#125;.DataSourceCSI1 = <span class="string">&#x27;PN9&#x27;</span> % CSI part 1 data <span class="built_in">source</span></span><br><span class="line">pusch&#123;1&#125;.DataSourceACK  = <span class="string">&#x27;PN9&#x27;</span> % HARQ-ACK data <span class="built_in">source</span></span><br></pre></td></tr></table></figure>
<ul>
<li>配置SRS<br>Specify SRS(sounding reference signal)</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">srs&#123;1&#125;.NumSRSPorts  =   1;  % Number of SRS ports</span><br><span class="line">srs&#123;1&#125;.NumSRSSymbols =  4;  % Number of SRS slor</span><br><span class="line">srs&#123;1&#125;.SymbolStart  =   10; % Time-domain positin of the SRS <span class="keyword">in</span> the slot</span><br><span class="line">srs&#123;1&#125;.FrequencyStart=  0;  % Frequency position of the SRS <span class="keyword">in</span> BWP <span class="keyword">in</span> RBs</span><br><span class="line">srs&#123;1&#125;.Period   =   5       % Allocation period <span class="keyword">in</span> slots</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>Waveform Generation<br>Assign all the channel and signal parameters to the main carrier configuration object(nrULCarrierConfig), then generate and plot the waveform.</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">waveconfig.SCSCarrier   =   scscarriers;</span><br><span class="line">waveconfig.BandwidthParts   =   bwp;</span><br><span class="line">waveconfig.PUSCH            =   pusch;</span><br><span class="line">waveconfig.SRS              =   srs;</span><br></pre></td></tr></table></figure>

<h2 id="概念学习"><a href="#概念学习" class="headerlink" title="概念学习"></a>概念学习</h2><h3 id="CSI"><a href="#CSI" class="headerlink" title="CSI"></a>CSI</h3><p>CSI信道状态矩阵是由UE通过Uplink发射给Basestation，CSI包含CSI1和CSI2</p>
<h4 id="CSI1"><a href="#CSI1" class="headerlink" title="CSI1"></a>CSI1</h4><p>主要传输的是预定义的、结构化的CSI信息，用于反馈诸如：</p>
<ul>
<li>PMI（Precoding Matrix Indicator）</li>
<li>RI（Rank Indicator）</li>
<li>LI（Layer Indicator）</li>
<li>Wideband CQI（Channel Quality Indicator）</li>
</ul>
<h4 id="CSI2"><a href="#CSI2" class="headerlink" title="CSI2"></a>CSI2</h4><p>传输的是更精细或更灵活的CSI信息，比如</p>
<ul>
<li>Subband CQI</li>
<li>CRIs（Codebook Reference Indices）</li>
<li>更复杂的PMI表达</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://hechenyi.github.io/2025/04/21/5gNRDownlink/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/04/21/5gNRDownlink/" class="post-title-link" itemprop="url">5gNRDownLink</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-04-21 20:49:12" itemprop="dateCreated datePublished" datetime="2025-04-21T20:49:12+08:00">2025-04-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 02:50:33" itemprop="dateModified" datetime="2025-04-28T02:50:33+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/5G/" itemprop="url" rel="index"><span itemprop="name">5G</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      
          <h2 id="Basic-description"><a href="#Basic-description" class="headerlink" title="Basic description"></a>Basic description</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openExample(<span class="string">&#x27;5g/NRDownlinkWaveformGenerationExample&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>This example shows how to configure and generate a <strong>5G NR downlink</strong> vector.<br>The generated waveform contains these channels and signals</p>
<ul>
<li>PDSCH and its associated DM-RS and PT-RS</li>
<li>PDCCH and its associated DM-RS</li>
<li>PBCH and its associated DM-RS</li>
<li>PSS and SSS</li>
<li>CSI-RS</li>
</ul>
<h3 id="SCS-specific-carriers"><a href="#SCS-specific-carriers" class="headerlink" title="SCS specific carriers"></a>SCS specific carriers</h3><ul>
<li>SubcarrierSpacing</li>
<li>NsizeGrid</li>
<li>StartGrid<br>NsizeGrid默认是52，说明整个带宽中有52个resource blocks，每个resource block有12个子载波</li>
</ul>
<h3 id="SS-burst"><a href="#SS-burst" class="headerlink" title="SS burst"></a>SS burst</h3><h4 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h4><p>SSB(SS&#x2F;PBCH Block)是一个包含PSS+SSS+PBCH的小结构，占用240个子载波（20PRBs）、4个OFDM符号<br>SS Burst是一个时间窗口（最多5ms），里面可以发多个SSB（最多64个，取决于配置）</p>
<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><ul>
<li>Enable</li>
<li>Power<br>用来设置SSB的相对功率，也就是和整个波形中其他部分的功率一样，不做放大或衰减。</li>
<li>BlockPattern<br>例如Case B（30KHz）表示subcarrier spacing</li>
<li>TransmittedBlocks<br>说明这5ms内发射的SSB个数</li>
<li>Period<br>发射SS Burst的周期</li>
<li>NCRBSSB</li>
</ul>
<h2 id="BWPs"><a href="#BWPs" class="headerlink" title="BWPs"></a>BWPs</h2><p>A BWP is formed by a set of contiguous resources sharing a numerology on a given SCS carrier.<br>例如如果在前面已经定义好了SCS carrier，例如RB数量，间距，那么在构建BWP的时候可以用到之前构建好的SCS，因此是share numerology</p>
<ul>
<li>BandwidthPartID</li>
<li>Label</li>
<li>SubcarrierSpacing</li>
<li>CyclicPrefix</li>
<li>NSizeBWP<br>表示这个BWP占据多少个RB</li>
<li>NStartBWP</li>
</ul>
<h2 id="PDCCH"><a href="#PDCCH" class="headerlink" title="PDCCH"></a>PDCCH</h2><p>Speicify the set of PDSCH transmission instances in the waveform by using a cell array. </p>
<ul>
<li><p>Enable</p>
</li>
<li><p>Label</p>
</li>
<li><p>BandwidthPartID<br>这个会和前面定义的BWP进行匹配</p>
</li>
<li><p>Power</p>
</li>
<li><p>Coding<br>Enable the DL-SCH transport channel coding</p>
</li>
<li><p>DataSource</p>
</li>
<li><p>Modulation</p>
</li>
<li><p>NumLayers  </p>
<ul>
<li>NumLayers &#x3D; 1,就相当于一个数据流（单层MIMO），也叫SISO</li>
<li>NumLayers &#x3D; 2，基站可以同时发两条独立的数据流到UE，UE徐亚至少有四个天线来接收，这属于2x2 MIMO</li>
<li>NumLayers &#x3D; 4，例如4x4到MIMO</li>
</ul>
</li>
<li><p>VRBToPRBInterleaving</p>
<ul>
<li>disable interleaver</li>
<li>enable intrleaver<br>  交错映射的作用是在频域上分散数据，提高对频率选择性衰落的抵抗力。<br>  VRB index:  0 1 2 3 4 5<br>  Mapped PRB: 0 1 4 5 2 3</li>
</ul>
</li>
<li><p>DM-RS(解调参考信号)</p>
<ul>
<li>DMRSConfigurationType</li>
<li>NumCDMGroupsWithoutData</li>
<li>DMRSPortSet</li>
<li>DMRSTypeAPosition</li>
<li>DMRSLength</li>
<li>DMRSAdditionalPosition（用来做scrambling，也就是说将发射给不同UE的信号区分开）</li>
<li>DMRS.NSCID</li>
</ul>
</li>
<li><p>CSI-RS</p>
<ul>
<li>Enable</li>
<li>Label</li>
<li>BandwidthPartID</li>
<li>Power</li>
<li>CSIRSType</li>
<li>RowNumber</li>
<li>CSIRSType</li>
<li>SubcarrierLocation</li>
<li>NumRB</li>
<li>RBOffset</li>
<li>SymbolLocations</li>
<li>CSIPeriod</li>
<li>NID</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://hechenyi.github.io/2025/04/21/5gNRSidelink/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/04/21/5gNRSidelink/" class="post-title-link" itemprop="url">5gNRSidelink</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-04-21 20:33:19" itemprop="dateCreated datePublished" datetime="2025-04-21T20:33:19+08:00">2025-04-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-19 06:33:54" itemprop="dateModified" datetime="2025-05-19T06:33:54+08:00">2025-05-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/5G/" itemprop="url" rel="index"><span itemprop="name">5G</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      
          <h2 id="Basic-discription-–-from-MATLAB"><a href="#Basic-discription-–-from-MATLAB" class="headerlink" title="Basic discription – from MATLAB"></a>Basic discription – from MATLAB</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openExample(<span class="string">&#x27;5g/NRSidelinkVectorWaveformGenerationExample&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>This example shows how to configure and generate a 5G NR sidelink baseband waveform containing a sequence of physical sidelink control channel (PSCCH) and physical sidelink shared channel (PSSCH) transmission, including sidelink control information (SCI) and SL-SCH transport channel coding.<br>NR sidelink uses the concept of resource pools to configure specific resources for transmission and reception on a sidelink carrier. Each data transmission comprises a PSCCH transmission and an associated PSSCH transmission. </p>
<h2 id="Steps"><a href="#Steps" class="headerlink" title="Steps"></a>Steps</h2><ul>
<li>set the parameters for the waveform and resource pool configuration<br>The waveform is based on the PSSCH reference measurement channels (RMCs) defined. 也就是它是根据一个参考channel进行构造的，但实际上你可以自定义参数。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rmc = R.PSSCH.2-1.2</span><br><span class="line">bwscs = 20MHx @ 30kHz</span><br><span class="line">% Get PSCCH and PSSCH channel and sidelink pool parameters</span><br><span class="line">bw = bwscs(1); </span><br><span class="line">scs = bwscs(2);</span><br><span class="line">[waveconfig.SLTransmission,waveconfig.Pool] = NRSidelinkResourcePool.rmcTestConfiguration(rmc,bw,scs);</span><br></pre></td></tr></table></figure>
<ul>
<li>Waveform Generation (create a baseband IQ waveform that contains a sequence of the previously configured PSCCH and PSSCH transmissions)<ul>
<li>Use a SL-SCH HARQ entity object to control the HARQ process and RV scheduling of the SL-SCH transport encoding, across the series of PSSCH transmissions in the waveform.</li>
<li>Create a set of PN23 data sources to stream the SL-SCH, SCI1, and SCI2 payloads across the sequence of transmisins.</li>
</ul>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sci1datasource = createPN23DataSource();</span><br><span class="line">sci2datasource = createPN23DataSource();</span><br></pre></td></tr></table></figure>
<ul>
<li>Create a pair of PSSCH DM-RS position configurations.</li>
<li>Create variable for the basestation waveform and related outputs</li>
<li>配置好了之后（Slot-wise loop to build the complete waveform from the sequence of individual PSSCH and PSCCH transmission）<br>  需要注意的是每个slot里面都有PSSCH和PSCCH</li>
</ul>
</li>
</ul>
<h2 id="基于openairinterface的sidelink"><a href="#基于openairinterface的sidelink" class="headerlink" title="基于openairinterface的sidelink"></a>基于openairinterface的sidelink</h2><h3 id="S-SSB"><a href="#S-SSB" class="headerlink" title="S-SSB"></a>S-SSB</h3><img src="/images/S-SSB.png">
一个完整的S-SSB包含S-PSS、S-SSS和PSBCH这几个部分

<ul>
<li>S-PSS: symbols 1, 2</li>
<li>S-SSS: symbols 3, 4</li>
<li>PSBCH: symbols 5 - 12<br>S-SSB uses 11 RBs, or 132 subcarriers.<br>The PSBCH provides the system wide configuration and synchronization information required to establish the connection between multiple UEs. Its payload size consists of 56 bits.<br><strong>DMRS</strong> are transmitted in every PSBCH, on every fourth subcarrier, the are used by the receiver to properly decode the PSBCH.</li>
</ul>
<h4 id="procedure"><a href="#procedure" class="headerlink" title="procedure"></a>procedure</h4><p>Create SL PSS<br>  |<br>Create SL SSS<br>  |<br>Fill in DMRS<br>  |<br>Generate PSBCH Payload<br>  |<br>Generate SSB Frame<br>  |<br>Conduct Symbol Rotation<br>  |<br>Encode PSBCH<br>  |<br>Detect SSS         &#x2F;&#x2F;&#x2F;接收端<br>  ｜<br>Correlated DMRS<br>  |<br>Extract PSBCH</p>
<h3 id="S-SSB-SPSS-and-SSSS-and-PSBCH"><a href="#S-SSB-SPSS-and-SSSS-and-PSBCH" class="headerlink" title="S-SSB (SPSS and SSSS) and PSBCH"></a>S-SSB (SPSS and SSSS) and PSBCH</h3><p><strong>nr_sl_initial_sync</strong>函数处理Sidelink S-SSB&#x2F;PSBCH block<br>In 5G sidelink, the first SSB symbol is the PSBCH, so the first thing is to adjust the SSB offset accordingly. The next symbols are PSS and SSS. So we need then to adjust the SSB offset accodingly (subtracting first PSS prefix). </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">uint32_t psbch_plus_prefix_size = fp-&gt;ofdm_symbol_size + fp-&gt;nb_prefix_samples;</span><br><span class="line">uint32_t num_pss_prefix_samples_size = (ue-&gt;common_vars.N2_id + 1) * fp-&gt;nb_prefix_samples;</span><br><span class="line">/// get and extract the corresponding SSB</span><br><span class="line"><span class="keyword">for</span> (int j = 0; j &lt; fp-&gt;slots_per_frame - 1; j++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (int i = 0; i &lt; N_SYMB_SLOT_SL; i++)</span><br><span class="line">nr_slot_fep_init_sync(ue, proc, i ,j ,is * fp-&gt;samples_per_frame + ue-&gt;ssb_offset);</span><br><span class="line">&#125;</span><br><span class="line">/// nr_slot_fep_init_sync 用来接收数据并做dft处理</span><br><span class="line"></span><br><span class="line">int nr_slot_fep_init_sync(PHY_VARS_NR_UE *ue,</span><br><span class="line">                          UE_nr_rxtx_proc_t *proc,</span><br><span class="line">                          unsigned char symbol,</span><br><span class="line">                          unsigned char Ns,</span><br><span class="line">                          int sample_offset)</span><br><span class="line">&#123; ///计算偏移值从而定位到对应的slot以及对应的symbol</span><br><span class="line">  unsigned int slot_offset = frame_parms-&gt;get_samples_slot_timestamp(Ns,frame_parms,0);</span><br><span class="line">  unsigned int rx_offset   = sample_offset + slot_offset;</span><br><span class="line">  unsigned int abs_symbol  = Ns * frame_parms-&gt;symbols_per_slot + symbol;</span><br><span class="line">  <span class="keyword">for</span> (int idx_symb = Ns*frame_parms-&gt;symbols_per_slot; idx_symb &lt;= abs_symbol; idx_symb++)</span><br><span class="line">    rx_offset += (abs_symbol%(0x7&lt;&lt;<span class="string">frame_parms-&gt;numerology_index)) ? nb_prefix_samples : nb_prefix_samples0;</span></span><br><span class="line"><span class="string">  rx_offset += frame_parms</span>-&gt;ofdm_symbol_size * symbol;</span><br><span class="line">  /// dft (<span class="keyword">time</span> domain symbols -&gt; frequency domain symbols)</span><br><span class="line">   dft(dftsize,</span><br><span class="line">        rxdata_ptr,</span><br><span class="line">        (int16_t *)&amp;common_vars-&gt;common_vars_rx_data_per_thread[proc-&gt;thread_id].rxdataF[aa][frame_parms-&gt;ofdm_symbol_size*symbol],</span><br><span class="line">        1);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">/// 之后对dft后的频域信号进行frequency offset的计算 （根据SSS来计算）</span><br><span class="line">/// DFT -&gt; rxdataF</span><br><span class="line"><span class="keyword">for</span> (Nid1 = 0; Nid1 &lt; N_ID_1_NUMBER; Nid1++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (uint8_t phase = 0; phase &lt; PHASE_HYPOTHESIS_NUMBER; phase++) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (int i = 0; i &lt; LENGTH_SSS_NR; i++) &#123;</span><br><span class="line">      metric_re += d[i] * (((phase_re_nr[phase] * sss0[<span class="number">2</span> *i ]) &gt;&gt; SCALING_METRIC_SSS_NR) - ((phase_im_nr[phase] * sss0[<span class="number">2</span> * i + <span class="number">1</span>]) &gt;&gt; SCALING_METRIC_SSS_NR))</span><br><span class="line">                 + d[i] * (((phase_re_nr[phase] * sss1[<span class="number">2</span> *i ]) &gt;&gt; SCALING_METRIC_SSS_NR) - ((phase_im_nr[phase] * sss1[<span class="number">2</span> * i + <span class="number">1</span>]) &gt;&gt; SCALING_METRIC_SSS_NR));</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">int re = 0, im = 0;</span><br><span class="line"><span class="keyword">for</span>(int i = 0; i &lt; LENGTH_SSS_NR; i++) &#123;</span><br><span class="line">  re += d[i] * sss0[2 * i];</span><br><span class="line">  im += d[i] * sss0[2 * i + 1];</span><br><span class="line">  re += d[i] * sss1[2 * i];</span><br><span class="line">  im += d[i] * sss1[2 * i + 1];</span><br><span class="line">&#125;</span><br><span class="line">double ffo_sss = atan2(im, re) / M_PI / 4.3;</span><br><span class="line">*freq_offset_sss = (int)(ffo_sss * frame_parms-&gt;subcarrier_spacing);</span><br><span class="line"></span><br><span class="line">/// compensation</span><br><span class="line"><span class="keyword">for</span> (int n = start; n &lt; end; n++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (int ar = 0; ar &lt; fp-&gt;nb_antennas_rx; ar++) &#123;</span><br><span class="line">              double re = ((double)(((short *)ue-&gt;common_vars.rxdata[ar]))[2 * n]);</span><br><span class="line">              double im = ((double)(((short *)ue-&gt;common_vars.rxdata[ar]))[2 * n + 1]);</span><br><span class="line">              ((short *)ue-&gt;common_vars.rxdata[ar])[<span class="number">2</span> * n] = (short)(round(re * cos(n * off_angle) - im * sin(n * off_angle)));</span><br><span class="line">              ((short *)ue-&gt;common_vars.rxdata[ar])[<span class="number">2</span> * n + <span class="number">1</span>] = (short)(round(re * sin(n * off_angle) + im *cos(n * off_angle)));</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">/// 处理psbch</span><br><span class="line">...</span><br></pre></td></tr></table></figure>





<h3 id="PSSCH-and-PSCCH"><a href="#PSSCH-and-PSCCH" class="headerlink" title="PSSCH and PSCCH"></a>PSSCH and PSCCH</h3><p>PSSCH contains SCI2 and DM-RS while PSCCH only contains SCI1.<br><img src="/images/PSSCH.png"></p>
<p>The SCI2 payload is <strong>polar</strong> encoded and contains the number of data bits transmitted as well as the multiplexing scheme. So the SCI2 is used by the decoder to properly decode the PSSCH payload, which uses a Low-Density Parity Check(LDPC) encoding mechanism. Besides, the SCI2 is used for the decoding of PSSCH for the HARQ operation.</p>
<h4 id="Procedures"><a href="#Procedures" class="headerlink" title="Procedures"></a>Procedures</h4><p>Generate SCI2           &#x2F;&#x2F;&#x2F;发射端<br> |<br>Polar Coding and Rate Matching<br> |<br>LDPC coding and Rate Matching<br> |<br>Data and Control Multiplexing<br> |<br>Scrambling<br> |<br>Constellation Modulation<br> |<br>Layer Mapping<br> |<br>Virtual resource and resource grid mapping<br> |<br>OFDM modulation<br> |<br>Tx&#x2F;Rx<br> |<br>OFDM Demodulation   &#x2F;&#x2F;&#x2F;接收端<br> |<br>Resource grid demapping<br> |<br>Channel Estimatin and Equalization<br> |<br>Layer demapping<br> |<br>Constellation demodulation<br> |<br>Descrambling<br> |<br>Data and control demultiplexing<br> |<br>LDPC decoding and polar decoding</p>
<h3 id="HARQ"><a href="#HARQ" class="headerlink" title="HARQ"></a>HARQ</h3><p>HARQ (Hybrid ARQ (Automatic Repeat Request)). It is a feedback transmission and reception 5G uses. It has such functionalities as blow:</p>
<ul>
<li><p>重传控制<br>用于管理是否需要重传(通过round， ndi， tx_status等字段)</p>
</li>
<li><p>数据存储<br>存储当前HARQ过程的数据，比如<strong>a_sci2</strong>, <strong>b_sci2</strong><br>其中a_sci2用于pointer to sci2 after crc + polar encoding and rate matching stored in bytes.<br>其中b_sci2用于pointer to output of data-control multiplexer in bits.<br>其他<strong>A_sci2</strong>和<strong>B_sci2</strong>用于表示数据大小in bits<br>B_sci2：用来表示数据的大小，使用 uint32_t 类型来存储大小（单位：比特），它是一个静态的数字，而不是实际的数据内容。<br>b_sci2：指向实际数据的指针，用来表示数据的内存地址，实际的数据内容存储在该地址指向的内存区域。使用指针是因为数据的长度不固定或可能变化，因此需要动态地分配和管理内存。</p>
</li>
<li><p>编码缓存<br>存储LDPC&#x2F;Polar编码输出及中间步骤</p>
</li>
<li><p>slot定位<br>指明此HARQ对应的slot and frame(frame, slot) </p>
</li>
<li><p>调度协助<br>辅助scheduler判断资源使用情况，是否有未完成HARQ</p>
</li>
</ul>
<h4 id="NR-UL-UE-HARQ-t"><a href="#NR-UL-UE-HARQ-t" class="headerlink" title="NR_UL_UE_HARQ_t"></a>NR_UL_UE_HARQ_t</h4><p>关键字段</p>
<ul>
<li>a_sci2<br>pointer to SCI2 payload from MAC interface</li>
<li>b_sci2<br>pointer to sci2 after crc+polar encoding and rate matching stored in bytes</li>
<li>*a<br>pointer to pdu from MAC interface(也就是payload)</li>
<li>*b<br>pointers to the payload + CRC</li>
</ul>
<h4 id="NR-DL-UE-HARQ-t"><a href="#NR-DL-UE-HARQ-t" class="headerlink" title="NR_DL_UE_HARQ_t"></a>NR_DL_UE_HARQ_t</h4><p>关键字段</p>
<ul>
<li>*b<br>pointer to the payload</li>
<li>B<br>the payload + crc size in bits</li>
<li>b_sci2<br>pointer to the sci2 payload</li>
<li>B_sci2<br>the sci2’s payload + CRC + channel coder + rate matching size in bits</li>
</ul>
<h3 id="TDD"><a href="#TDD" class="headerlink" title="TDD"></a>TDD</h3><p>The flexible slot feature of 5G SL utilizes each symbol to schedule uplink, downlink, or flexible packets. According to the 3GPP standard, the S-SBB should be periodicity of 160 ms(10ms per system frame number, 0.5 ms per slot). There are other modifiable parameters like interval parameter, offset parameter, number S-SSB per period.<br><img src="/images/SSSB_TDD.png"></p>
<p>So in this test use case, we arbitrarily chose to broadcast 2 S-SSBs per period. The first S-SSB is sent in slot 2 because we set the offset parameter to 2. The interal parameter was set to 20.<br>20+2-10ms&#x2F;0.5ms &#x3D; 2<br>so the next S-SSb will be transmitted twice in a period, and occurs in frame 1 slot 2.</p>
<h4 id="S-SSB后SCH-PSSCH-PSCCH-之间的时隔划分"><a href="#S-SSB后SCH-PSSCH-PSCCH-之间的时隔划分" class="headerlink" title="S-SSB后SCH(PSSCH &amp; PSCCH)之间的时隔划分"></a>S-SSB后SCH(PSSCH &amp; PSCCH)之间的时隔划分</h4><p>在SL Mode 2中，时隔划分是由UE自身配置的S-SSB周期&#x2F;偏移&#x2F;间隔决定（例如在某个slot发射S-SSB在另外的slot内发射SCH），这是由UE本地RRC Layer来配置的。在本次实验中，查看代码可知S-SSB是每个160ms发射一次S-SSB，代码可见&#x2F;openair1&#x2F;SCHED_NR_UE&#x2F;phy_procedures_nr_ur.c<br>先从RRC层获取S-SSB的各种参数配置，例如一个周期(160ms)内有多少个S-SSB，第一个S-SSB的偏移量还有两个S-SSB之间的间隔</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">bool phy_ssb_slot_allocation_sl(PHY_VARS_NR_UE *ue, int frame, int slot)</span><br><span class="line">&#123;</span><br><span class="line">  NR_DL_FRAME_PARMS *fp = &amp;ue-&gt;frame_parms;</span><br><span class="line">  static int sl_numssb_withinperiod_r16, sl_timeoffsetssb_r16, sl_timeoffsetssb_r16_copy;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (sl_numssb_withinperiod_r16 == 0) &#123;</span><br><span class="line">    sl_numssb_withinperiod_r16 = ue-&gt;slss-&gt;sl_numssb_withinperiod_r16;</span><br><span class="line">    sl_timeoffsetssb_r16 = ue-&gt;slss-&gt;sl_timeoffsetssb_r16;</span><br><span class="line">    sl_timeoffsetssb_r16_copy = sl_timeoffsetssb_r16;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((frame * fp-&gt;slots_per_frame + slot) % (<span class="number">16</span> * fp-&gt;slots_per_frame) == <span class="number">0</span>) &#123;</span><br><span class="line">    ue-&gt;slss-&gt;sl_numssb_withinperiod_r16 = ue-&gt;slss-&gt;sl_numssb_withinperiod_r16_copy;</span><br><span class="line">    sl_timeoffsetssb_r16 = frame * fp-&gt;slots_per_frame + sl_timeoffsetssb_r16_copy;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (ue-&gt;slss-&gt;sl_numssb_withinperiod_r16 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    if (frame * fp-&gt;slots_per_frame + slot == sl_timeoffsetssb_r16) &#123;</span><br><span class="line">      sl_timeoffsetssb_r16 = sl_timeoffsetssb_r16 + ue-&gt;slss-&gt;sl_timeinterval_r16;</span><br><span class="line">      ue-&gt;slss-&gt;sl_numssb_withinperiod_r16 = ue-&gt;slss-&gt;sl_numssb_withinperiod_r16 - <span class="number">1</span>;</span><br><span class="line">      LOG_I(PHY,&quot;*** SL-SSB slot allocation  %d.%d ***\n&quot;, frame, slot); </span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于syncref ue，以0-15 frames 为例，frame 0 ， frame 1中的slot 1会发射SSB，然后在其他的frame中的slot1或者slot0会发射PSSCH，代码如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">uint32_t sl_bitmap_tx = 0x00000;</span><br><span class="line"><span class="keyword">if</span>(ue-&gt;sync_ref) &#123;</span><br><span class="line">  sl_bitmap_tx = (ue-&gt;is_synchronized_sl == 0) ? 0x00001 : 0x00002;  // SyncRef UE tx slot 0, Relay UE B tx slot 1.</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((sl_bitmap_tx &gt;&gt; slot_tx) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">  for (uint8_t harq_pid = <span class="number">0</span>; harq_pid &lt; <span class="number">1</span>; harq_pid++) &#123;</span><br><span class="line">    nr_ue_set_slsch(&amp;ue-&gt;frame_parms, harq_pid, ue-&gt;slsch[proc-&gt;thread_id][gNB_id], frame_tx, slot_tx);</span><br><span class="line">    if (ue-&gt;slsch[proc-&gt;thread_id][gNB_id]-&gt;harq_processes[harq_pid]-&gt;status == ACTIVE) &#123;</span><br><span class="line">      nr_ue_slsch_tx_procedures(ue, harq_pid, frame_tx, slot_tx);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于nearby ue，也是从每个frame中的特定slot去获取pssch</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">int phy_procedures_nrUE_SL_RX(PHY_VARS_NR_UE *ue,</span><br><span class="line">                           UE_nr_rxtx_proc_t *proc,</span><br><span class="line">                           uint8_t synchRefUE_id,</span><br><span class="line">                           notifiedFIFO_t *txFifo) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ue-&gt;is_synchronized_sl == 0)</span><br><span class="line">    <span class="built_in">return</span> (0);</span><br><span class="line"></span><br><span class="line">  // TODO: Need to add rx SSB slot 2 (to Relay UE) and rx SSB slot 4 (Nearby UE) <span class="keyword">for</span> resync</span><br><span class="line">  uint32_t sl_bitmap_rx = ue-&gt;sync_ref ? 0x00001 : 0x00002; // Relay UE B rx slot 0, Nearby UE rx slot 1.</span><br><span class="line">  <span class="keyword">if</span> (((sl_bitmap_rx &gt;&gt; proc-&gt;nr_slot_rx) &amp; <span class="number">1</span>) == <span class="number">0</span>) </span><br><span class="line">    return (<span class="number">0</span>);</span><br><span class="line">  int frame_rx = proc-&gt;frame_rx;</span><br><span class="line">  int slot_rx = proc-&gt;nr_slot_rx;</span><br><span class="line">  uint32_t ret = nr_ue_slsch_rx_procedures(ue, harq_pid, frame_rx, slot_rx, rxdataF, B_mul, Nidx, proc);</span><br><span class="line"></span><br><span class="line">  bool payload_type_string = true;</span><br><span class="line">  bool polar_decoded = (ret &lt; LDPC_MAX_LIMIT) ? true : false;</span><br><span class="line">  uint16_t dest = (*harq-&gt;b_sci2 &gt;&gt; <span class="number">32</span>) &amp; <span class="number">0</span>xFFFF;</span><br><span class="line">  bool dest_matched = (dest == node_id);</span><br><span class="line">  if (polar_decoded)</span><br><span class="line">    LOG_D(PHY, &quot;dest %u vs %u node_id for hex %lx\n&quot;, dest, node_id, *harq-&gt;b_sci2);</span><br><span class="line">  if ((ret != -<span class="number">1</span>) &amp;&amp; dest_matched) &#123;</span><br><span class="line">    if (payload_type_string)</span><br><span class="line">        validate_rx_payload_str(harq, slot_rx, polar_decoded);</span><br><span class="line">        else</span><br><span class="line">        validate_rx_payload(harq, frame_rx, slot_rx, polar_decoded);</span><br><span class="line">              &#125;</span><br></pre></td></tr></table></figure>


<hr>
<blockquote>
<p><strong>Notice</strong><br><br>sl-numSSB-WithinPeriod-r16, sl-timeInterval-r16, sl-SSB-PeriodicityAndOffset-r16这些和S-SSB的时序相关的配置根据<strong>3GPP</strong>规范明确出现在<strong>RRC</strong>层定义的Sidelink配置结构中。</p>
</blockquote>
<hr>
<h3 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h3><h4 id="Sidelink-Sequence-Diagram"><a href="#Sidelink-Sequence-Diagram" class="headerlink" title="Sidelink Sequence Diagram"></a>Sidelink Sequence Diagram</h4><p>…<br>自己画(Synchronization ue和nearby ue之间的通信)</p>
<h4 id="Sidelink-Block-Diagram"><a href="#Sidelink-Block-Diagram" class="headerlink" title="Sidelink Block Diagram"></a>Sidelink Block Diagram</h4><img src="/images/SidelinkBlockDiagram.png">

<h4 id="RSRP-Reference-signal-received-power"><a href="#RSRP-Reference-signal-received-power" class="headerlink" title="RSRP (Reference signal received power)"></a>RSRP (Reference signal received power)</h4><p>分别计算了SSB-RSRP和PSSCH-RSRP<br>以下是PSSCH-RSRP的计算公式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">\mathrm&#123;RSRP&#125;_&#123;\mathrm&#123;dBm&#125;&#125;</span><br><span class="line">= 10 \log_&#123;10&#125;\Bigl(P_&#123;\mathrm&#123;lin&#125;&#125;\Bigr)</span><br><span class="line">  + 30</span><br><span class="line">  - 10 \log_&#123;10&#125;\bigl(2^&#123;30&#125;\bigr)</span><br><span class="line">  - \bigl(G_&#123;\mathrm&#123;rx&#125;&#125; - G_&#123;\mathrm&#123;off&#125;&#125;\bigr)</span><br><span class="line">  - \mathrm&#123;dB\_fixed&#125;(N_&#123;\mathrm&#123;fft&#125;&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中$P_{lin}$是对所有测量到的资源元素（RE）功率取平均后的线性功率，其中$10\log_{10}(2^{30})$是因为系统用30位定点数表示FFT输出，数值实际上被乘了$2^{30}$,因此需要减去这个缩放因子。除此之外还需要减去补偿放大器带来的功率增益。同时还要减去不同FFT大小（即OFDM子载波总数）下的单位子载波的功率密度变化。</p>
<p>从哪些信号计算rsrp？：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (int k = 0; k &lt; nb_rb * NR_NB_SC_PER_RB; k += 4) &#123;</span><br><span class="line">  <span class="comment">#ifdef DEBUG_MEAS_UE</span></span><br><span class="line">  LOG_I(N_pssch %d %d\n<span class="string">&quot;, __FUNCTION__, rxF_pssch[k * 2], rxF_pssch[k * 2 + 1]);</span></span><br><span class="line"><span class="string">  #endif</span></span><br><span class="line"><span class="string">  rsrp += (((int32_t)rxF_pssch[k * 2] * rxF_pssch[k * 2]) + ((int32_t)rxF_pssch[k * 2 + 1] * rxF_pssch[k * 2 + 1]));</span></span><br><span class="line"><span class="string">  nb_re++;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>每4个子载波取一次DMRS信号来进行测量received power，对每一个抽样点先取实数平方加虚部平方，得到这个RE到线性功率，累加到rsrp。</p>
<h4 id="Sync-time"><a href="#Sync-time" class="headerlink" title="Sync time"></a>Sync time</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#796821.854505 [NR_PHY] SyncRef UE found with Nid1 10 and Nid2 1 SS-RSRP -100 dBm/RE</span></span><br><span class="line">  <span class="keyword">if</span> not line.startswith(<span class="string">&#x27;[&#x27;</span>) and <span class="string">&#x27;SyncRef UE found&#x27;</span> <span class="keyword">in</span> line and <span class="string">&#x27;Nid1&#x27;</span> <span class="keyword">in</span> line and <span class="string">&#x27;Nid2&#x27;</span> <span class="keyword">in</span> line:</span><br><span class="line">      num_split = 13 <span class="keyword">if</span> <span class="string">&#x27;RSRP&#x27;</span> <span class="keyword">in</span> line <span class="keyword">else</span> 10</span><br><span class="line">      fields = line.split(maxsplit=num_split)</span><br><span class="line">      est_nid1 = int(fields[7])</span><br><span class="line">      est_nid2 = int(fields[10])</span><br><span class="line">      <span class="keyword">if</span> <span class="string">&#x27;RSRP&#x27;</span> <span class="keyword">in</span> line:</span><br><span class="line">            ssb_rsrp = int(fields[12])</span><br><span class="line">      found.add(<span class="string">&#x27;syncref&#x27;</span>)</span><br><span class="line">      time_end_s = <span class="built_in">float</span>(fields[0])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>同步时间平均是7-8秒，对应的SSB数目是除0.16秒再乘2<br>因为周期是160ms，并且一个周期内有2个SSB</p>
<h4 id="Packet-Loss-Rate"><a href="#Packet-Loss-Rate" class="headerlink" title="Packet Loss Rate"></a>Packet Loss Rate</h4><p>Successfully decoded packets</p>
<h4 id="Data-rates"><a href="#Data-rates" class="headerlink" title="Data rates"></a>Data rates</h4><ul>
<li>所有数据</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">uint32_t B_mul = get_B_multiplexed_value(&amp;ue-&gt;frame_parms, slsch-&gt;harq_processes[0]);</span><br><span class="line">uint32_t get_B_multiplexed_value(NR_DL_FRAME_PARMS* fp, NR_DL_UE_HARQ_t *harq) &#123;</span><br><span class="line"></span><br><span class="line">  uint8_t Nl                = harq-&gt;Nl;</span><br><span class="line">  unsigned int G_slsch_bits = harq-&gt;G;</span><br><span class="line">  uint32_t B_mul = G_slsch_bits + harq-&gt;B_sci2 * Nl;</span><br><span class="line">  <span class="built_in">return</span> B_mul;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中harq-&gt;nl是Number of MIMO layers (streams), harq-&gt;G是Number of soft channel bits，<br>最终<strong>B_mul</strong>是整个Sidelink PDU中所有实际通过空口传输的比特数(数据+控制)，可以用来估算实际的PHY吞吐量。</p>
<p>其中harq-G具体计算如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">uint32_t nr_get_G_sl(uint16_t nb_rb, uint16_t nb_re_sci1, uint16_t nb_re_sci2, uint16_t nb_symb_sch, uint8_t nb_re_dmrs, uint16_t length_dmrs, uint8_t Qm, uint8_t Nl) &#123;</span><br><span class="line">    uint32_t G;</span><br><span class="line">    G = (((NR_NB_SC_PER_RB * nb_symb_sch)-(nb_re_dmrs * length_dmrs)) * nb_rb - nb_re_sci1 - nb_re_sci2) * Qm * Nl;</span><br><span class="line">    <span class="built_in">return</span>(G);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中NR_NB_SC_PER_RB是每个资源块包含的子载波数，一个RB包含12个子载波<br>nb_symb_sch 是该slot内的符号数量。其中<strong>nb_rb</strong>是资源块数量，在oai中通常标准化为50的倍数，例如我们在脚本中把rbsl设为了52，但在oai中会变为50。其中<strong>Qm</strong>表示每个RE的的调制比特数，例如QPSK &#x3D; 2，16QAM &#x3D; 4<br>最终nr_get_G_sl的返回值是12480，说明整个pssch的bits是12480，这表示一个slot中传输的数据总比特数，包括： PSSCH数据部分 + SCI2控制信息部分的比特总数。harq-&gt;G是11904bits，这表示整个PSSCH传输中当前slot可承载的数据比特数（理论最大），也就是不包含SCI2控制信息<br>吞吐量 &#x3D; 12480&#x2F;0.0005 &#x3D; 24960000 bits&#x2F;s &#x3D; 24.96 Mbps &#x3D; 3.12 MB&#x2F;s<br>而这时理论上一个slot上的吞吐量，如果放到整一个frame中，那么吞吐量 &#x3D; 24960000 bits&#x2F;s &#x2F; 20 &#x3D; <strong>1248000</strong> bits&#x2F;s<br>（因为一个frame只有一个slot用于pssch传输）<br>在实际测试中，data rate大约为<strong>1188000</strong> bis&#x2F;s,略小于理论速率，因此合理。（可能是由于丢包导致的）<br>overview of parameters:</p>
<ul>
<li>MCS<br>0, so it is QPSK</li>
<li>RB<br>52个RB然后被oai归一化为50，每个RB中有12个子载波  </li>
<li>SCS<br>子载波间隔为30kHz，这样算下来带宽为18MHx（50x12x30），但是还有一些guard band（保护带），因此实际带宽会更大，大约为标准化带宽20MHz</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void nr_ue_set_slsch_rx(PHY_VARS_NR_UE *ue, unsigned char harq_pid)</span><br><span class="line">&#123;</span><br><span class="line">  int nb_rb = get_PRB(ue-&gt;frame_parms.N_RB_SL);</span><br><span class="line">  uint16_t nb_symb_sch = 12;</span><br><span class="line">  uint16_t nb_symb_cch = 3; // Assumption there are three SLCCH symbols</span><br><span class="line">  uint8_t dmrsConfigType = 0;</span><br><span class="line">  uint8_t Nl = 1; // number of layer</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="Latency-self-defined"><a href="#Latency-self-defined" class="headerlink" title="Latency(self-defined)"></a>Latency(self-defined)</h4><p>histogram latency<br>对于发射端<br>在nr_ue_slsch_tx_procedures函数中某一位置加上时间戳，例如在modulation + layer mapping + resource mapping之后，但是在nr_ue_pssch_common_procedures()函数之前，因为nr_ue_pssch_common_procedures()涉及具体的把信号加到RF端。<br>对于接收端<br>在nr_ue_slsch_rx_procedures函数内，在nr_slsch_decoding之后</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">uint32_t ret = nr_slsch_decoding(rxUE, proc, ulsch_llr[0],</span><br><span class="line">                          &amp;rxUE-&gt;frame_parms, slsch_ue_rx,</span><br><span class="line">                          slsch_ue_rx-&gt;harq_processes[0], frame,</span><br><span class="line">                          nb_symb_sch, slot, harq_pid);</span><br><span class="line">///////////////////////////////////////////////////////</span><br><span class="line">LOG_I(NR_PHY,<span class="string">&quot;Frame: %d, Slot: %d&quot;</span>, frame, slot);</span><br><span class="line"><span class="built_in">return</span> ret;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="Resources-blocks"><a href="#Resources-blocks" class="headerlink" title="Resources blocks"></a>Resources blocks</h4><p>具体可见paper（只需要考虑PSSCH和PSCCH）<br>因为只需要关心real data<br>Resource blocks可以推导出theoretical data rates</p>
<h3 id="How-would-improve"><a href="#How-would-improve" class="headerlink" title="How would improve"></a>How would improve</h3><p>例如如何改良resource blocks</p>
<h4 id="改动地方"><a href="#改动地方" class="headerlink" title="改动地方"></a>改动地方</h4><ul>
<li>ue-&gt;sync_ref &#x3D; 0</li>
<li>polar_decoder_int16 failed</li>
<li>validate_rx_str<br>问题：<br>sync过几秒就不再接收了</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://hechenyi.github.io/2025/04/21/C%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/04/21/C%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" class="post-title-link" itemprop="url">C基本概念</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-04-21 15:19:37" itemprop="dateCreated datePublished" datetime="2025-04-21T15:19:37+08:00">2025-04-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-08-04 12:55:41" itemprop="dateModified" datetime="2025-08-04T12:55:41+08:00">2025-08-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      
          <h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>指针变量本身的值是地址，X64有2的64次方个内存地址，因此指针占8个字节。<br>指针变量通常是栈上的变量。<br>指针指向的内存可以是栈上变量的地址，也可以是堆上分配的内存地址。</p>
<h2 id="malloc-new"><a href="#malloc-new" class="headerlink" title="malloc&amp;new"></a>malloc&amp;new</h2><ul>
<li>malloc （C）<ul>
<li>malloc不会调用构造析构函数</li>
<li>malloc返回无类型的指针（因此需要转换一下，char* p &#x3D; (char*) malloc(100)）</li>
</ul>
</li>
<li>new&#x2F;delete （C++）<ul>
<li>new 返回有类型的指针</li>
<li>new调用构造析构函数</li>
</ul>
</li>
</ul>
<p>二者都是在堆上动态性地存储变量。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"></span><br><span class="line">struct Person &#123;</span><br><span class="line">    char name[50];</span><br><span class="line">    int age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    struct Person* p = (struct Person*)malloc(sizeof(struct Person));</span><br><span class="line">    <span class="keyword">if</span> (!p) &#123;</span><br><span class="line">        perror(<span class="string">&quot;malloc failed&quot;</span>);</span><br><span class="line">        <span class="built_in">return</span> 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    strcpy(p-&gt;name, <span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">    p-&gt;age = 30;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Name: %s, Age: %d\n&quot;</span>, p-&gt;name, p-&gt;age);</span><br><span class="line"></span><br><span class="line">    free(p);  // ❗必须释放</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="STL六大组件"><a href="#STL六大组件" class="headerlink" title="STL六大组件"></a>STL六大组件</h2><ul>
<li>仿函数</li>
<li>算法</li>
<li>迭代器</li>
<li>空间配置器</li>
<li>容器</li>
<li>配接器</li>
</ul>
<h3 id="使用std-unordered-map构建hash-map"><a href="#使用std-unordered-map构建hash-map" class="headerlink" title="使用std::unordered_map构建hash map"></a>使用std::unordered_map构建hash map</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;unordered_map&gt;</span></span><br><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string&gt;</span></span><br><span class="line">std::unordered_map&lt;std::string, int&gt; word_count;</span><br><span class="line">word_count[<span class="string">&quot;apple&quot;</span>] = 3;</span><br><span class="line">word_count.insert(&#123;<span class="string">&quot;orange&quot;</span>, 7&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><ul>
<li>创建</li>
<li>就绪</li>
<li>运行</li>
<li>堵塞</li>
<li>死亡</li>
</ul>
<h2 id="静态连接"><a href="#静态连接" class="headerlink" title="静态连接"></a>静态连接</h2><ul>
<li>创建一个静态库（.a文件）</li>
<li>编译为静态库</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ -c math_utils.cpp -o math_utils.o</span><br><span class="line">ar rcs libmathutils.a math_utils.o</span><br></pre></td></tr></table></figure>
<ul>
<li>使用静态库的主函数</li>
<li>静态连接并编译生成可执行文件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ main.cpp -L. -lmathutils -o app</span><br></pre></td></tr></table></figure>

<h2 id="构建结构体"><a href="#构建结构体" class="headerlink" title="构建结构体"></a>构建结构体</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">typedef struct notifiedFIFO_elt_s&#123;</span><br><span class="line">    struct notifiedFIFO_elt_s *next;</span><br><span class="line">    uint64_t key;</span><br><span class="line">    /// 构建一个空的函数指针，在使用的时候可以将其进行强制转换</span><br><span class="line">    void (*processingFunc) (void *);</span><br><span class="line">    bool malloced;</span><br><span class="line">    /// oai的系统结构体，可以用于性能测试</span><br><span class="line">    oai_cputime_t creationTime;</span><br><span class="line">    oai_cputime_t startProcessingTime;</span><br><span class="line">    oai_cputime_t endProcessingTime;</span><br><span class="line">    oai_cputime_t returnTime;</span><br><span class="line">    /// 空的指针，在使用的时候可以进行强制转换</span><br><span class="line">    void *msgData; </span><br><span class="line">&#125;   notifiedFIFO_elt_t;</span><br></pre></td></tr></table></figure>

<h3 id="强行转换并使用msgData指针"><a href="#强行转换并使用msgData指针" class="headerlink" title="强行转换并使用msgData指针"></a>强行转换并使用msgData指针</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">notifiedFIFO_elt_t *Msg = newNotifiedFIFO_elt(sizeof(syncData_t), 0, &amp;nf, UE_synch);</span><br><span class="line">syncData_t *syncMsg = (syncData_t *) NotifiedFifoData(Msg));</span><br><span class="line">syncMsg-&gt;UE = UE;</span><br><span class="line">memset(&amp;syncMsg-&gt;proc, 0, sizeof(syncMsg-&gt;proc));</span><br><span class="line">pushTpool(&amp;(get_nrUE_params()-&gt;Tpool), Msg);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>pushTpool</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">static inline void pushTpool(tpool_t *t, notifiedFIFO_elt_t *msg) &#123;</span><br><span class="line">  <span class="keyword">if</span> (t-&gt;measurePerf) msg-&gt;creationTime=rdtsc_oai();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( t-&gt;activated)</span><br><span class="line">    pushNotifiedFIFO(&amp;t-&gt;incomingFifo, msg);</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (t-&gt;measurePerf)</span><br><span class="line">      msg-&gt;startProcessingTime=rdtsc_oai();</span><br><span class="line"></span><br><span class="line">    msg-&gt;processingFunc(NotifiedFifoData(msg));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t-&gt;measurePerf)</span><br><span class="line">      msg-&gt;endProcessingTime=rdtsc_oai();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (msg-&gt;reponseFifo)</span><br><span class="line">      pushNotifiedFIFO(msg-&gt;reponseFifo, msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="📘-C-指针和字符串字面量示例"><a href="#📘-C-指针和字符串字面量示例" class="headerlink" title="📘 C 指针和字符串字面量示例"></a>📘 C 指针和字符串字面量示例</h2><h3 id="📌-1-基础示例：指针初始化"><a href="#📌-1-基础示例：指针初始化" class="headerlink" title="📌 1. 基础示例：指针初始化"></a>📌 1. 基础示例：指针初始化</h3><p>✅ 正确用法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> *a = &amp;x;  <span class="comment">// a 指向 x 的地址</span></span><br><span class="line">    *a = <span class="number">2</span>;       <span class="comment">// 修改 x 的值</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x = %d\n&quot;</span>, x);  <span class="comment">// 输出：2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>🚫 错误用法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> *a = <span class="number">1</span>;   <span class="comment">// 错误！a 指向地址 0x1，几乎肯定无效</span></span><br><span class="line">    *a = <span class="number">2</span>;       <span class="comment">// 未定义行为，可能段错误</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="📌-2-字符串字面量是只读的"><a href="#📌-2-字符串字面量是只读的" class="headerlink" title="📌 2. 字符串字面量是只读的"></a>📌 2. 字符串字面量是只读的</h3><p>✅ 正确示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> *a = <span class="string">&quot;a&quot;</span>;  <span class="comment">// a 指向字符串字面量 &quot;a&quot;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, a);  <span class="comment">// 输出：a</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 🚫 不要尝试修改只读字符串：</span></span><br><span class="line">    <span class="comment">// a[0] = &#x27;b&#x27;; // 可能段错误</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="📌-3-可修改字符串：使用数组"><a href="#📌-3-可修改字符串：使用数组" class="headerlink" title="📌 3. 可修改字符串：使用数组"></a>📌 3. 可修改字符串：使用数组</h3><p>✅ 正确示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> a[] = <span class="string">&quot;a&quot;</span>; <span class="comment">// 创建一个可修改的数组</span></span><br><span class="line">    a[<span class="number">0</span>] = <span class="string">&#x27;b&#x27;</span>;     <span class="comment">// 修改成功</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, a);  <span class="comment">// 输出：b</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="📌-4-内存示意"><a href="#📌-4-内存示意" class="headerlink" title="📌 4. 内存示意"></a>📌 4. 内存示意</h3><table>
<thead>
<tr>
<th>表达式</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>a</code></td>
<td>指针变量，保存一个地址</td>
</tr>
<tr>
<td><code>*a</code></td>
<td>访问指针指向地址中的值</td>
</tr>
<tr>
<td><code>&amp;x</code></td>
<td>取变量 x 的地址</td>
</tr>
<tr>
<td><code>&quot;abc&quot;</code></td>
<td>字符串字面量（只读）</td>
</tr>
</tbody></table>
<hr>
<h3 id="📌-5-char-a-vs-char-a"><a href="#📌-5-char-a-vs-char-a" class="headerlink" title="📌 5. char *a vs char a[]"></a>📌 5. <code>char *a</code> vs <code>char a[]</code></h3><table>
<thead>
<tr>
<th>声明</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>char *a = &quot;abc&quot;;</code></td>
<td>a 是指针，指向只读字符串字面量</td>
</tr>
<tr>
<td><code>char a[] = &quot;abc&quot;;</code></td>
<td>a 是数组，内容拷贝到栈上，可修改</td>
</tr>
</tbody></table>
<hr>
<h3 id="✅-总结"><a href="#✅-总结" class="headerlink" title="✅ 总结"></a>✅ 总结</h3><ol>
<li><strong>指针变量保存的是地址，解引用（<code>*a</code>）访问该地址中的值。</strong></li>
<li><strong>字符串字面量通常是只读内存，想要可修改字符串就要用数组拷贝出来。</strong></li>
<li><strong>对无效地址解引用会导致未定义行为（段错误、程序崩溃）。</strong></li>
</ol>
<hr>
<h3 id="✨-完整示例：可复制运行"><a href="#✨-完整示例：可复制运行" class="headerlink" title="✨ 完整示例：可复制运行"></a>✨ 完整示例：可复制运行</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 指针操作</span></span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> *p = &amp;x;</span><br><span class="line">    *p = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x = %d\n&quot;</span>, x);  <span class="comment">// 输出：20</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字符串字面量（只读）</span></span><br><span class="line">    <span class="type">char</span> *s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可修改字符串（数组）</span></span><br><span class="line">    <span class="type">char</span> s2[] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    s2[<span class="number">0</span>] = <span class="string">&#x27;H&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s2);  <span class="comment">// 输出：Hello</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="define和const的区别"><a href="#define和const的区别" class="headerlink" title="define和const的区别"></a>define和const的区别</h2><p><strong>编译阶段</strong>： define是编译预处理阶段进行简单的文本替换，const是在编译阶段确定其值<br><strong>安全性</strong>： define定义的宏常量没有数据类型，只是进行简单的替换，不会进行类型安全检查；const定义的常量是有类型的，是要进行类型判断的<br><strong>内存占用</strong>： define定义的宏常量，在程序中使用多少次就会进行多少次替换，内存中有多个备份，占用的是代码段的内存；const定义常量占用静态存储区域的空间，程序运行过程中只有一份<br><strong>调试</strong>： define定义的宏常量不能调试，因为在预编译阶段就已经进行替换了；const定义的常量是可以进行调试的。</p>
<h2 id="程序运动的步骤是什么"><a href="#程序运动的步骤是什么" class="headerlink" title="程序运动的步骤是什么"></a>程序运动的步骤是什么</h2><ul>
<li>预编译。<br>将头文件编译，进行宏替换，输出.i文件</li>
<li>编译。<br>将其转换为汇编语言文件，主要做语法分析，语义分析以及检查错误，检查无误后将代码替换成汇编语言，生成.s文件</li>
<li>汇编。<br>汇编器将汇编语言文件翻译成机器语言，生成.o文件</li>
<li>链接。<br>将目标文件和库链接到一起，生成可执行文件.exe</li>
</ul>
<h2 id="进程之间的通信方式"><a href="#进程之间的通信方式" class="headerlink" title="进程之间的通信方式"></a>进程之间的通信方式</h2><ul>
<li>管道</li>
<li>消息队列</li>
<li>共享内存</li>
<li>信号量</li>
<li>信号</li>
<li>套接字</li>
</ul>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h3><ul>
<li>第一次握手</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">客户端 --&gt; 服务端 ： SYN = 1， seq = x</span><br></pre></td></tr></table></figure>
<ul>
<li>第二次握手</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">服务端 --&gt; 客户端 ： SYN=1, ACK=1, seq=y, ack=x+1</span><br></pre></td></tr></table></figure>
<ul>
<li>第三次握手</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">客户端 --&gt; 服务端 ： ACK=1, seq=x+1, ack=y+1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="断开连接"><a href="#断开连接" class="headerlink" title="断开连接"></a>断开连接</h3><ul>
<li>第一次握手<br>客户端发送<strong>FIN</strong>包,表示自己没有数据要发了，但还能接受数据</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">客户端 --&gt; 服务端 ： FIN=1, seq=u</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>第二握手<br>服务端收到 FIN 后，发送 ACK 确认包，表示“我知道你要断了”。</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">服务端 --&gt; 客户端 ： ACK=1, ack=u+1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>第三次握手<br>服务端发完剩余数据后，发送自己的 FIN 包，表示也没数据了。</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">服务端 --&gt; 客户端 ： FIN=1, seq=v</span><br></pre></td></tr></table></figure>

<ul>
<li>第四次握手（客户端确认）<br>客户端收到服务端的 FIN 后，发送 ACK 确认，表示“好，我知道你也断了”。</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">客户端 --&gt; 服务端 ： ACK=1, ack=v+1</span><br></pre></td></tr></table></figure>


<h2 id="动态连接和静态连接"><a href="#动态连接和静态连接" class="headerlink" title="动态连接和静态连接"></a>动态连接和静态连接</h2><p>区别：他们的最大区别就是在于链接的时机不同，静态链接是在形成可执行程序前，而动态链接的进行则是程序执行时。</p>
<p>静态库：就是将库中的代码包含到自己的程序之中，每个程序链接静态库后，都会包含一份独立的代码，当程序运行起来时，所有这些重复的代码都需要占用独立的存储空间，显然很浪费计算机资源。</p>
<p>动态库：不会将代码直接复制到自己程序中，只会留下调用接口，程序运行时再去将动态库加载到内存中，所有程序只会共享这一份动态库，因此动态库也被称为共享库。</p>
<p>动态链接原理：是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://hechenyi.github.io/2025/04/21/OFDM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/04/21/OFDM/" class="post-title-link" itemprop="url">OFDM</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-04-21 14:50:57" itemprop="dateCreated datePublished" datetime="2025-04-21T14:50:57+08:00">2025-04-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-08-28 15:13:48" itemprop="dateModified" datetime="2025-08-28T15:13:48+08:00">2025-08-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/5G/" itemprop="url" rel="index"><span itemprop="name">5G</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      
          <h2 id="Basic-Concept"><a href="#Basic-Concept" class="headerlink" title="Basic Concept"></a>Basic Concept</h2><hr>
<blockquote>
<p><strong>Notice</strong><br><br>一个OFDM符号在时域上的长度等于FFTLength + CyclicPrefixLength<br><br>一个OFDM符号在频域上的长度等于有效子载波长度,也就是FFTLength - NullCarrierIndices(空载波(直流、保护带))</p>
</blockquote>
<hr>
<p>在OFDM中，一个OFDM符号就是多个子载波的结合，每个子载波承载一个调制符号（如QPSK、 16QAM、 64QAM等）<br>所以一个OFDM符号在频域中会有多个调制符号，IFFT就是把这些调制符号转换成时域的连续符号，变成一个OFDM符号。<br>整体的过程是modData -&gt; 插入pilot -&gt; 插入null（清零无效子载波）-&gt; 子载波分配与映射 -&gt; IFFT -&gt; 加CP -&gt; ofdmDataOut</p>
<p>其中子载波分配是指OFDM将整个频谱分成若干个正交的子载波，每个调制符号会被映射到一个子载波上。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s(t_m) = \sum_&#123;n=0&#125;^&#123;N-1&#125;[I_ncosw_nt_m - Q_n sinw_nt_m] = Re \sum_&#123;n=0&#125;^&#123;N-1&#125;[(I_n + jQ_n)e^&#123;jw_nt_m&#125;]</span><br></pre></td></tr></table></figure>
<p>其中$\sum_{n&#x3D;0}^{N-1}[(I_n + jQ_n)e^{jw_nt_m}]$是IDFT的形式，再结合IFFT因此可将上式子转变为：  </p>
<p>$Re[IFFT(I_n + jQ_n)]$  </p>
<p>因此可将$Z_n &#x3D; I_n + jQ_n$理解为OFDM信号在DFT的频谱上的离散点。从上述表达式实现了每个符号乘以一个复指数信号（频率为该子载波的频率）进行映射。也就是说，每个符号都会与一个正弦或余弦波相乘，并根据子载波的频率进行偏移。</p>
<p>IFFT: 对调制后的符号进行 逆离散傅里叶变换（IFFT），将频域信号转换为时域信号。IFFT 是将各个子载波的信号合成在一起的步骤，在这个步骤之后，信号由频域转为时域。<br>在matlab仿真中，data为原始复数对，X_freq为频域信号，zeros(FFT_size,1),装有data，这样就实现了将原始数据加载到子载波上，然后$X_{time} &#x3D; ifft(ifftshift(X_{freq}), N)$</p>
<h2 id="OFDM-子载波时域与频域特性说明"><a href="#OFDM-子载波时域与频域特性说明" class="headerlink" title="OFDM 子载波时域与频域特性说明"></a>OFDM 子载波时域与频域特性说明</h2><h3 id="OFDM-子载波的频域表示"><a href="#OFDM-子载波的频域表示" class="headerlink" title="OFDM 子载波的频域表示"></a>OFDM 子载波的频域表示</h3><p>在 OFDM 系统中，信号在频域由多个子载波组成，每个子载波对应一个特定的频率分量。假设有 (N) 个子载波，总频域信号为：</p>
<p>$$<br>X[k], \quad k &#x3D; 0, 1, \ldots, N-1<br>$$</p>
<p>其中，$X[k]$ 是第 $k$ 个子载波的复数调制符号（例如 QAM 符号）。</p>
<hr>
<h3 id="单个子载波的时域信号"><a href="#单个子载波的时域信号" class="headerlink" title="单个子载波的时域信号"></a>单个子载波的时域信号</h3><p>如果频域信号只有第 $k_0$ 个子载波为非零（例如为1），其余均为零：</p>
<p>$$<br>X[k] &#x3D; \begin{cases}<br>1, &amp; k &#x3D; k_0 \<br>0, &amp; k \neq k_0<br>\end{cases}<br>$$</p>
<p>则时域信号通过逆离散傅里叶变换（IFFT）得到：</p>
<p>$$<br>x[n] &#x3D; \frac{1}{N} \sum_{k&#x3D;0}^{N-1} X[k] e^{j 2\pi \frac{k n}{N}} &#x3D; \frac{1}{N} e^{j 2\pi \frac{k_0}{N} n}, \quad n&#x3D;0, 1, \ldots, N-1<br>$$</p>
<p>这表示时域是一个频率为 $\frac{k_0}{N}$ 的复指数序列（正弦波），且长度为 $N$。</p>
<hr>
<h3 id="为什么子载波时域是带频移的-sinc-函数？"><a href="#为什么子载波时域是带频移的-sinc-函数？" class="headerlink" title="为什么子载波时域是带频移的 sinc 函数？"></a>为什么子载波时域是带频移的 sinc 函数？</h3><ul>
<li><strong>理想情况</strong>：无限长的单频正弦波对应频域单点（Dirac δ函数）。</li>
<li><strong>实际情况</strong>：时域信号有限长（长度为$N$），等价于将无限长正弦波乘以一个矩形窗：</li>
</ul>
<p>$$<br>x_{\text{windowed}}[n] &#x3D; \frac{1}{N} e^{j 2\pi \frac{k_0}{N} n} \cdot w[n]<br>$$</p>
<p>其中：</p>
<p>$$<br>w[n] &#x3D; \begin{cases}<br>1, &amp; 0 \leq n &lt; N \<br>0, &amp; \text{otherwise}<br>\end{cases}<br>$$</p>
<ul>
<li><p><strong>矩形窗的频域对应一个 sinc 函数</strong>，因此频域不再是单一点，而是一个带主瓣和旁瓣的 sinc 函数形状。</p>
</li>
<li><p>反过来，频域中某个频率点实际代表一个<strong>带频移的 sinc 函数</strong>在时域的表现。</p>
</li>
</ul>
<hr>
<h3 id="对-frac-1-N-e-j-2-pi-frac-k-0-N-n-进行求DTFT"><a href="#对-frac-1-N-e-j-2-pi-frac-k-0-N-n-进行求DTFT" class="headerlink" title="对$\frac{1}{N} e^{j 2\pi \frac{k_0}{N} n}$进行求DTFT"></a>对$\frac{1}{N} e^{j 2\pi \frac{k_0}{N} n}$进行求DTFT</h3><p>对该信号进行离散时间傅里叶变换（DTFT）：</p>
<p>$$<br>X(e^{j\Omega}) &#x3D; \sum_{n&#x3D;-\infty}^{\infty} x[n] \cdot e^{-j\Omega n}<br>$$</p>
<p>代入 (x[n])：</p>
<p>$$<br>X(e^{j\Omega}) &#x3D; \frac{1}{N} \sum_{n&#x3D;-\infty}^{\infty} e^{-j n \left( \Omega - \frac{2\pi k_0}{N} \right)}<br>$$</p>
<p>角频率 $\Omega$ 和实际频率 $f$ 之间的关系为：</p>
<p>$$<br>\Omega &#x3D; 2\pi \frac{f}{f_s} \quad \Rightarrow \quad f &#x3D; \frac{\Omega}{2\pi} f_s<br>$$</p>
<p>所以主冲击的位置频率为：<br>$$<br>\Delta f &#x3D; \Delta \Omega \cdot \frac{f_s}{2\pi}<br>$$</p>
<p>所以频移为<br>$$<br>f_{k_0} &#x3D; \frac{2\pi \cdot \frac{k_0}{N} f_s}{2\pi} &#x3D; \frac{k_0}{N} f_s<br>$$</p>
<p>这正是我们设定的第 $k_0$个子载波的频移！<br>因此相邻子载波间距等于 $\frac{1}{N}  f_s$</p>
<hr>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><table>
<thead>
<tr>
<th>频域特征</th>
<th>时域对应信号</th>
</tr>
</thead>
<tbody><tr>
<td>单个频率点（理想 Dirac δ）</td>
<td>无限长正弦波（复指数）</td>
</tr>
<tr>
<td>有限长度时域（乘矩形窗）</td>
<td>带频移的 sinc 函数（矩形窗乘正弦波）</td>
</tr>
</tbody></table>
<p>因此，OFDM 中每个子载波在时域表现为一个带频移的 sinc 函数，而整个 OFDM 信号是多个带频移 sinc 函数的叠加。</p>
<hr>
<h3 id="OFDM-时域信号与频偏补偿说明"><a href="#OFDM-时域信号与频偏补偿说明" class="headerlink" title="OFDM 时域信号与频偏补偿说明"></a>OFDM 时域信号与频偏补偿说明</h3><p>先需要理解Carrier Frequency Offset（CFO）的概念，CFO会严重破坏子载波正交性，必须在接收端估计并补偿它</p>
<ul>
<li><p>使用前导符号（preamble）&#x2F;同步符号估计</p>
</li>
<li><p>使用CP（循环前缀）重复特征</p>
</li>
<li><p>最大似然估计（MLE）</p>
</li>
<li><p>基于同步信号块（PSS&#x2F;SSS）<br>这里我们使用PSS&#x2F;SSS来计算频偏补偿<br>根据上面分析可知OFDM系统中，发送的时域信号$r(t)$是由所有子载波的复指数调整信号叠加而成：<br>$$<br>r(t) &#x3D; \sum_{k&#x3D;0}^{N-1} X_k \cdot e^{j 2\pi k \Delta f t}<br>$$</p>
</li>
<li><p><code>N</code>: 子载波数量  </p>
</li>
<li><p><code>Xₖ</code>: 第 <code>k</code> 个子载波的调制符号（如 QAM）  </p>
</li>
<li><p><code>Δf</code>: 子载波间隔  </p>
</li>
<li><p><code>t</code>: 时间  </p>
</li>
<li><p><code>r(t)</code>: 发送的时域复数信号（OFDM 符号）</p>
</li>
</ul>
<p>离散形式(IFFT运算(IDFT)):<br>$$<br>r[n] &#x3D; \sum_{k&#x3D;0}^{N-1} X_k \cdot e^{j2\pi k n &#x2F; N}<br>$$</p>
<p>频偏$\Delta f$是指发送端和接收端本地载波振荡器之间存在的频率差异  </p>
<p>根据以下公式来进行调整<br>$$<br>\hat{r}[n] &#x3D; r[n] \cdot e^{j 2 \pi f_{\text{off}} n T_s}<br>$$</p>
<h3 id="MATLAB-代码示例"><a href="#MATLAB-代码示例" class="headerlink" title="MATLAB 代码示例"></a>MATLAB 代码示例</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">N = <span class="number">1024</span>;              <span class="comment">% 子载波总数（IFFT大小）</span></span><br><span class="line">k0 = <span class="number">300</span>;              <span class="comment">% 选择一个子载波索引</span></span><br><span class="line">X = <span class="built_in">zeros</span>(N,<span class="number">1</span>);</span><br><span class="line">X(k0) = <span class="number">1</span>;             <span class="comment">% 频域单点激活</span></span><br><span class="line">x = ifft(ifftshift(X), N); <span class="comment">% 得到时域信号</span></span><br><span class="line"></span><br><span class="line">n = <span class="number">0</span>:N<span class="number">-1</span>;</span><br><span class="line"><span class="built_in">plot</span>(n, <span class="built_in">real</span>(x));</span><br><span class="line">title(<span class="string">&#x27;单个子载波时域波形（带频移的 sinc 函数形态）&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;采样点 n&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;幅度&#x27;</span>);</span><br><span class="line">grid on;</span><br></pre></td></tr></table></figure>




<h3 id="payload处理"><a href="#payload处理" class="headerlink" title="payload处理"></a>payload处理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">dataBits = txParamConfig.txDataBits;</span><br><span class="line">% Append CRC bits to data bits</span><br><span class="line">crcData = crcGenerate(dataBits, txObj.crcDataGen);</span><br><span class="line">% Additively scramble using scramble polynomial</span><br><span class="line">scrOut = xor(crcData, txObj.pnSeq(sysParam.initState));</span><br><span class="line">% Perform convolutional coding</span><br><span class="line">dataEnc = convenc([scrOut;zeros(dataConvK-1,1)], ...</span><br><span class="line">    poly2trellis(dataConvK,dataConvCode),puncVec); % Terminated mode</span><br><span class="line">dataEnc = [dataEnc; zeros(sysParam.trBlkPadSize,1)]; % append pad to factorize payload length</span><br><span class="line">dataEnc = reshape(dataEnc,[],numDataOFDMSymbols); % form columns of symbols</span><br><span class="line">% Perform interleaving and symbol</span><br><span class="line">modData = zeros(numel(dataEnc)/(numDataOFDMSymbols*bitsPerModSym),numDataOFDMSymbols);</span><br><span class="line"><span class="keyword">for</span> i = 1:numDataOFDMSymbols</span><br><span class="line">    % Interleave each symbol</span><br><span class="line">    intrlvOut = OFDMInterleave(dataEnc(:,i),sysParam.dataIntrlvNcolumns);</span><br><span class="line">    % Modulate the symbol</span><br><span class="line">    modData(:,i) = qammod(intrlvOut, txParamConfig.modOrder, UnitAveragePower=<span class="literal">true</span>, InputType=<span class="string">&quot;bit&quot;</span>);</span><br><span class="line">end</span><br><span class="line">modDataInt = 1</span><br><span class="line">% Remove the pilot indices from modData indices</span><br><span class="line">modDataInd(pilotInd) = [];</span><br><span class="line">% Load data and pilots on the grid</span><br><span class="line">grid(pilotInd, (headerIdx+1:numSymPerFrame)) = pilot;</span><br><span class="line">grid(modDataInd, (headerIdx+1:numSymPerFrame)) = modData;</span><br></pre></td></tr></table></figure>
<p>分析代码，可知modData的维度的宽是numel(dataEnc)&#x2F;(numDataOFDMSymbols<em>bitsPerModSym)，<br>其中numel(dataEnc)所有的bits number， numDataOFDMSymbols</em>bitsPerModSym表示每一个Frame的OFDM符号数<strong>乘上</strong>每个调制后的符号的bits数（例如4QAM有两个bits），这样既可以计算出每个OFDM符号对应的子载波数，也就是调制符号数，这是对于payload而言<br>接下来是OFDM调制</p>
<h3 id="OFDM-Modulation"><a href="#OFDM-Modulation" class="headerlink" title="OFDM Modulation"></a>OFDM Modulation</h3><p>我们以payload为例，也就是对moddata进行调制<br>ofdmDataOut &#x3D; ofdmmod(modData, fftLen, cpLen, nullInd, sysParam.pilotIdx,pilot)<br>输入了每个OFDM符号的IFFT点数，每个OFDM符号前面加的循环前缀长度，要清零的子载波位置，导频子载波位置和导频符号。<br>在modData里根据pilotIdx，把pilot符号插到指定位置，IFFT运算则是把频域上的复数符变成时域信号。<br>输出的维度是(fftLen+cpLen) x numDataOFDMSymbols, 1<br>也就是一个列向量，表示多个OFDM符号在时域上串联在一起的结构，因为每个OFDM符号变成fftLen+cpLen个时域采样点</p>
<h3 id="采样频率"><a href="#采样频率" class="headerlink" title="采样频率"></a>采样频率</h3><p>采样率 &#x3D; 子载波数量 x 子载波间隔<br>这是5G NR的特性<br>数学证明:<br>$f_{sampling} &#x3D; \frac{n_{subcarrier} * n_{OFDMSymbolsPerSlot}}{T_{slot}} &#x3D; \frac{n_{subcarrier}}{T_{TimePerSymbol}} &#x3D; n_{subcarrier} * \Delta f$  </p>
<hr>
<blockquote>
<p><strong>Notice</strong><br><br>需要注意的是这里的子载波数量包含使用和未使用的子载波，也就是等于FFT size (针对一个OFDM符号而言，也就是对x[n]的一个OFDM符号采样后的离散信号进行ifft变换)，所以不完全等于带宽（带宽只由使用的子载波数量决定， CP只占据时间资源而不占据频域资源）, FFT size （N）本质上是对长度为N的时域信号进行变换，默认把这段信号看成是周期性重复的。一个OFDM符号的采样点数目通常等于FFT size。如果采样点数目要大于FFT size，那么可以逐块做FFT，如果采样点数目要小，那么做FFT时一般会补零（zero-padding）。</p>
</blockquote>
<hr>
<h2 id="MATLAB-example"><a href="#MATLAB-example" class="headerlink" title="MATLAB example"></a>MATLAB example</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openExample(<span class="string">&#x27;comm/OFDMEndToEndExample&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="basic-description"><a href="#basic-description" class="headerlink" title="basic description"></a>basic description</h2><img src="/images/dataflow.png">  

<p>This example shows how to run a complete end-to-end OFDM transimission for a single-input single-output (SISO) channel. The physical-layer transmission protocol mimics typical <strong>synchonization signals</strong>, <strong>reference symbols</strong>, <strong>control channels</strong>, and <strong>data channels</strong> popular across standardized transmission schemes such as LTE, 5G NR, and WLAN.</p>
<h2 id="Channel-Parameters"><a href="#Channel-Parameters" class="headerlink" title="Channel Parameters"></a>Channel Parameters</h2><ul>
<li>SNR<br>20dB</li>
<li>foff</li>
<li>doppler</li>
<li>pathDelay</li>
<li>pathGain</li>
</ul>
<h2 id="System-Parameters"><a href="#System-Parameters" class="headerlink" title="System Parameters"></a>System Parameters</h2><ul>
<li>FFTLen<br>1024</li>
<li>numFrames<br>100</li>
<li>numSymbolsPerFrame<br>15</li>
<li>CPLen<br>256</li>
<li>txDatabits<br>[…]</li>
<li>usedSubCarr<br>600</li>
<li>modulationOrder<br>64&#x3D;64-QAM</li>
<li>codeRate<br>0&#x3D;1&#x2F;2</li>
<li>BW<br>10MHz</li>
<li>fc(carrier frequency)<br>1.9GHz</li>
<li>enableFading<br>True</li>
</ul>
<h2 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h2><h3 id="Populate-Parameter-Structure"><a href="#Populate-Parameter-Structure" class="headerlink" title="Populate Parameter Structure"></a>Populate Parameter Structure</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">///helperOFDMSetParameters <span class="keyword">function</span></span><br><span class="line">[sysParam, txParam] = helperOFDMSetParameters(userParam);</span><br><span class="line">///通过查表来进一步获取FFTLen, CPLen, numSubCarr, BW等数据</span><br><span class="line">[~,codeParam] = helperOFDMGetTables(userParam.BWIndex,userParam.codeRateIndex);</span><br></pre></td></tr></table></figure>
<h3 id="Initialize-states-and-process-data-frames"><a href="#Initialize-states-and-process-data-frames" class="headerlink" title="Initialize states and process data frames"></a>Initialize states and process data frames</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/// Initialize transmitter and receiver</span><br><span class="line">txObj = helperOFDMTxInit(sysParam);</span><br><span class="line">rxObj = helperOFDMRxInit(sysParam);</span><br><span class="line">/// 循环发送，大循环是信噪比，用来模拟不同环境，小循环是frames的数量，用来一个frame一个frame的发送</span><br><span class="line"><span class="keyword">for</span> simLoopIdx = 1:length(SNRdB)</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> frameNum = 1 : sysParam.numFrames+1</span><br><span class="line">        sysParam.frameNum = frameNum;</span><br><span class="line">        /// Generate Payload data</span><br><span class="line">        txParam.txDatabits = randi([0 1], sysParam.trBlkSize, 1);</span><br><span class="line">        /// Store data bits <span class="keyword">for</span> BER calculation</span><br><span class="line">        sysParam.txDatabits = [sysParam.txDatabits; txParam.txDataBits];</span><br><span class="line">        /// Transmit data</span><br><span class="line">        [txOut, txGrid, txDiagnostics] = helperOFDMTx(txParam, sysParam, txObj);</span><br><span class="line">        /// 经过模拟的channel进行传送</span><br><span class="line">        chanOut = helperOFDMChannel(txOut, chanParam, sysParam);</span><br><span class="line">        /// Run the receiver front-end</span><br><span class="line">        rxIn = helperOFDMRxFrontEnd(chanOut, sysParam, rxObj);</span><br><span class="line">        /// Run the receiver processing</span><br><span class="line">        [rxDataBits, isConnected, toff, rxDiagnostics] = helperOFDMRx(rxIn, sysParam, rxObj);</span><br><span class="line">        /// Collect bit and frame error statistics</span><br><span class="line">        <span class="keyword">if</span> is Connected</span><br><span class="line">            BER = errorRate(...</span><br><span class="line">                sysParam.txDataBits(end-(2*sysParam.trBlkSize)+(1:sysParam.trBlkSize)), ...</span><br><span class="line">                rxDataBits);</span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/blog/page/4/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/blog/">1</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/4/">4</a><span class="page-number current">5</span>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">45</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">categories</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
